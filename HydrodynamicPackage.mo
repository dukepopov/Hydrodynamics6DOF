package Hydrodynamic
  package Example
    extends Modelica.Icons.Package;

    model SingleBodyWEC1D "1D Single-Body Wave Energy Converter Model"
      extends Modelica.Icons.Example;
      // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-54, -20}, extent = {{-10, -10}, {10, 10}})));
      // Force application component
      Modelica.Mechanics.MultiBody.Forces.WorldForce force "Applies the excitation force to the body" annotation(
        Placement(transformation(origin = {42, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      // Prismatic joint for vertical motion
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 0, 1}) "Prismatic joint allowing vertical motion" annotation(
        Placement(transformation(origin = {-22, -20}, extent = {{-10, -10}, {10, 10}})));
      // Hydrodynamic body component
      Forces.BodyHD6D bodyHD6D "Hydrodynamic body with 6 degrees of freedom" annotation(
        Placement(transformation(origin = {12, -20}, extent = {{-10, -10}, {10, 10}})));
      // Wave profile component
      WaveProfile.IrregularWave.PiersonMoskowitzWave piersonMoskowitzWave annotation(
        Placement(transformation(origin = {78, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
    equation
// Connections between components
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-44, -20}, {-32, -20}}, color = {95, 95, 95}));
      connect(force.frame_b, bodyHD6D.frame_b) annotation(
        Line(points = {{32, -20}, {22, -20}}, color = {95, 95, 95}));
      connect(prismatic.frame_b, bodyHD6D.frame_a) annotation(
        Line(points = {{-12, -20}, {2, -20}}, color = {95, 95, 95}));
      connect(piersonMoskowitzWave.y, force.force) annotation(
        Line(points = {{68, -20}, {54, -20}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}), Polygon(points = {{-60, 0}, {60, 80}, {60, -80}, {-60, 0}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid), Line(points = {{-100, 40}, {-30, 0}, {40, 60}, {100, 20}}, color = {0, 0, 255}, thickness = 1.5, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Line(points = {{0, 100}, {0, 20}}, color = {0, 0, 255}, thickness = 1.5)}),
        Documentation(info = "<html>
          <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
          <p>This model represents a simplified 1D single-body wave energy converter system, 
          focusing on the vertical motion of the body in response to wave excitation forces.</p>
          
          <p><b>Model Description</b></p>
          <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
          The body is subjected to wave excitation forces generated by an irregular JONSWAP wave spectrum.</p>
          
          <p><b>Key Components</b></p>
          <ul>
            <li><code>world</code>: Defines the world coordinate system without gravity</li>
            <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
            <li><code>prismatic</code>: Allows vertical motion of the body</li>
            <li><code>jonswapWave</code>: Generates irregular wave excitation forces</li>
            <li><code>force</code>: Applies the excitation force to the body</li>
          </ul>
          
          <p><b>Assumptions and Simplifications</b></p>
          <ul>
            <li>The model considers only vertical motion (1D) of the WEC</li>
            <li>Gravity is not included in the world model</li>
            <li>The excitation force is applied as an external input based on the JONSWAP spectrum</li>
          </ul>
          
          <p><b>Notes</b></p>
          <ul>
            <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
            <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
            <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
            <li>The JONSWAP wave parameters may need to be adjusted to represent specific sea states</li>
          </ul>
        </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {100, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end SingleBodyWEC1D;
    annotation(
      Icon(graphics = {Rectangle(extent = {{-80, 80}, {80, -80}}, lineColor = {0, 0, 255}, fillColor = {230, 230, 250}, fillPattern = FillPattern.Solid), Polygon(points = {{-40, 40}, {40, 0}, {-40, -40}, {-40, 40}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-100, -80}, {100, -120}}, lineColor = {0, 0, 255}, textString = "%name")}),
      Documentation(info = "<html>
        <p><b>Wave Energy Converter (WEC) Examples</b></p>
        <p>This package contains example models for Wave Energy Converter (WEC) systems. 
        It provides a set of ready-to-use models that demonstrate various aspects of WEC modeling and simulation.</p>
        
        <p><b>Package Contents</b></p>
        <ul>
          <li><b>SingleBodyWEC1D</b>: A 1D model of a single-body wave energy converter.</li>
        </ul>
        
        <p><b>Usage</b></p>
        <p>The models in this package can be used as starting points for more complex WEC simulations 
        or as educational tools to understand the basic principles of WEC modeling.</p>
        
        <p><b>See Also</b></p>
        <p>For more detailed information on individual models, please refer to their respective documentation.</p>
      </html>"));
  end Example;

  package Forces
    model DragForce6D "6-Dimensional Drag Force and Torque Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      
      // Fluid and reference parameters
      parameter Real rho = 1.25 "Density of fluid [kg/m^3]";
      parameter Real A = 1 "Reference area [m^2]";
      // Drag coefficients
      parameter Real Cdx = 1 "Translational drag coefficient for x-axis [-]";
      parameter Real Cdy = 1 "Translational drag coefficient for y-axis [-]";
      parameter Real Cdz = 1 "Translational drag coefficient for z-axis [-]";
      parameter Real Crx = 1 "Rotational drag coefficient for x-axis [-]";
      parameter Real Cry = 1 "Rotational drag coefficient for y-axis [-]";
      parameter Real Crz = 1 "Rotational drag coefficient for z-axis [-]";
      parameter Real Cd[6, 6] = diagonal({Cdx, Cdy, Cdz, Crx, Cry, Crz}) "Combined drag coefficient matrix";
      // Control parameter
      parameter Boolean enableDragForce = true "Switch to enable/disable drag force calculation";
      // Internal variables
      Real c "Combined constant term for drag calculation";
      Real fd[6] "6D drag force/torque vector [N, N*m]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
    equation
// Calculate the combined constant term
      c = 0.5*rho*A;
// Combine linear and angular velocities into a single vector
      v_omega = cat(1, v_abs, omega_abs);
// Calculate the 6D drag force/torque vector
      fd = -c*Cd*v_omega.*abs(v_omega);
// Use the switch to conditionally output the force and torque
      if enableDragForce then
        F = fd[1:3];

      else
        F = zeros(6);

      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional drag force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The drag force/torque is calculated using a quadratic drag model, where the force is proportional to the square of the velocity.</p>
        <p>The block can be enabled or disabled using the <code>enableDragForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>a</code>: Angular velocity vector [rad/s]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational drag force vector [N]</li>
          <li><code>y1</code>: Rotational drag torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>rho</code>: Fluid density [kg/m^3]</li>
          <li><code>A</code>: Reference area [m^2]</li>
          <li><code>Cdx</code>, <code>Cdy</code>, <code>Cdz</code>: Translational drag coefficients [-]</li>
          <li><code>Crx</code>, <code>Cry</code>, <code>Crz</code>: Rotational drag coefficients [-]</li>
        </ul>
        <p>The drag coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
      </html>"));
    end DragForce6D;

    block PTO6D "6-Dimensional Power Take-Off (PTO) System"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      
      // Proportional gain parameters
      parameter Real Kpx = 0.1 "Proportional gain for x-axis translation [N/(m/s)]";
      parameter Real Kpy = 0.1 "Proportional gain for y-axis translation [N/(m/s)]";
      parameter Real Kpz = 0.1 "Proportional gain for z-axis translation [N/(m/s)]";
      parameter Real Kprx = 0.1 "Proportional gain for x-axis rotation [N*m/(rad/s)]";
      parameter Real Kpry = 0.1 "Proportional gain for y-axis rotation [N*m/(rad/s)]";
      parameter Real Kprz = 0.1 "Proportional gain for z-axis rotation [N*m/(rad/s)]";
      parameter Real Kp[6, 6] = diagonal({Kpx, Kpy, Kpz, Kprx, Kpry, Kprz}) "Combined proportional gain matrix";
      // Integral gain parameters
      parameter Real Kix = 0.1 "Integral gain for x-axis translation [N/m]";
      parameter Real Kiy = 0.1 "Integral gain for y-axis translation [N/m]";
      parameter Real Kiz = 0.1 "Integral gain for z-axis translation [N/m]";
      parameter Real Kirx = 0.1 "Integral gain for x-axis rotation [N*m/rad]";
      parameter Real Kiry = 0.1 "Integral gain for y-axis rotation [N*m/rad]";
      parameter Real Kirz = 0.1 "Integral gain for z-axis rotation [N*m/rad]";
      parameter Real Ki[6, 6] = diagonal({Kix, Kiy, Kiz, Kirx, Kiry, Kirz}) "Combined integral gain matrix";
      // Control parameter
      parameter Boolean enablePTOForce = true "Switch to enable/disable PTO force calculation";
      // Internal variable
      Real fpto[6] "Combined PTO force/torque vector [N, N*m]";
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
       
    equation
     u_theta = cat(1,u_abs,theta_abs);
     v_omega = cat(1, v_abs, omega_abs);
// Calculate the combined PTO force/torque vector
      fpto = Kp*v_omega + Ki*u_theta;
// Use the switch to conditionally output the force and torque
      if enablePTOForce then
        F = -fpto;

      else
        F = zeros(6);

      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block models a 6-dimensional Power Take-Off (PTO) system for both translational and rotational motion.</p>
        <p>The PTO force/torque is calculated using a combination of proportional and integral control based on the input velocities and displacements.</p>
        <p>The block can be enabled or disabled using the <code>enablePTOForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>s</code>: Linear displacement vector [m]</li>
          <li><code>omega</code>: Angular velocity vector [rad/s]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational PTO force vector [N]</li>
          <li><code>y1</code>: Rotational PTO torque vector [N*m]</li>
        </ul>
      </html>"));
    end PTO6D;

    model HydrostaticForce6D "6-Dimensional Hydrostatic Force and Torque Calculation"
     
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.forceTorque_con;
    
    
      // Hydrostatic restoring coefficients
      parameter Real G1 = 0 "Hydrostatic restoring coefficient for x-axis translation [N/m]";
      parameter Real G2 = 0 "Hydrostatic restoring coefficient for y-axis translation [N/m]";
      parameter Real G3 = 2800951.20000000 "Hydrostatic restoring coefficient for z-axis translation [N/m]";
      parameter Real G4 = 0 "Hydrostatic restoring coefficient for x-axis rotation [N*m/rad]";
      parameter Real G5 = 0 "Hydrostatic restoring coefficient for y-axis rotation [N*m/rad]";
      parameter Real G6 = 0 "Hydrostatic restoring coefficient for z-axis rotation [N*m/rad]";
      parameter Real G[6, 6] = diagonal({G1, G2, G3, G4, G5, G6}) "Combined hydrostatic restoring coefficient matrix";
      
      
      // Enable/disable force
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation";
      
      // Internal variables
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real fhs[6] "Hydrostatic force/torque vector [N, N*m]";
      
    equation
// Combine linear and angular displacements into a single vector
      u_theta = cat(1,u_abs,theta_abs);
// Calculate the 6D hydrostatic force/torque vector
      fhs = -G*u_theta;
// Use the switch to conditionally output the force and torque
      if enableHydrostaticForce then
        F = fhs;
      else
        F = zeros(6);
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional hydrostatic force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The hydrostatic force/torque is calculated using linear restoring coefficients, where the force is proportional to the displacement from the equilibrium position.</p>
        <p>The block can be enabled or disabled using the <code>enableHydrostaticForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear displacement vector [m]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational hydrostatic force vector [N]</li>
          <li><code>y1</code>: Rotational hydrostatic torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>G1</code>, <code>G2</code>, <code>G3</code>: Translational hydrostatic restoring coefficients [N/m]</li>
          <li><code>G4</code>, <code>G5</code>, <code>G6</code>: Rotational hydrostatic restoring coefficients [N*m/rad]</li>
        </ul>
        <p>The hydrostatic restoring coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
        <p>Note: By default, only the z-axis translation (heave) has a non-zero restoring coefficient, which is typical for floating bodies.</p>
      </html>"));
    end HydrostaticForce6D;

    model RadiationF "1D Radiation Force Calculation for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      
      // Input connectors
      Modelica.Blocks.Interfaces.RealInput z[3] "Position vector [m] (not used in calculations)" annotation(
        Placement(transformation(extent = {{-140, -60}, {-100, -20}})));
      Modelica.Blocks.Interfaces.RealInput v[3] "Velocity vector [m/s] (only vertical component used)" annotation(
        Placement(transformation(extent = {{-140, 20}, {-100, 60}})));
      // Output connector
      Modelica.Blocks.Interfaces.RealOutput F[6] "Radiation force vector [N] (only vertical component non-zero)" annotation(
        Placement(transformation(extent = {{100, -10}, {120, 10}})));
      // State-space model parameters for 1D radiation force
      parameter Real A[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 1D model";
      parameter Real B[2] = {683236.706073938, -585411.342188539} "Input vector for 1D model";
      parameter Real C[2] = {1, 0} "Output vector for 1D model";
      parameter Real D = 0 "Feed-through scalar for 1D model";
      // Control parameter
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
      // State variables
      Real x[2] "State vector for 1D radiation force model";
      Real F_rad "Calculated 1D radiation force [N]";
    initial equation
      x = {0, 0} "Initialize state vector to zero";
    equation
// 1D Radiation force state-space model
// Note: Only the third element of the velocity vector (vertical motion) is used
      der(x) = A*x + B*v[3];
      F_rad = C*x + D*v[3];
// Output: 1D radiation force only in the third element (vertical direction), with enable/disable switch
      if enableRadiationForce then
        F = {0, 0, -F_rad,0,0,0};
      else
        F = {0,0,0,0, 0, 0};
      end if;
      annotation(
        Documentation(info = "<html>
        <h4>1D Radiation Force Model for Hydrodynamic Systems</h4>
        <p>This model calculates the radiation force for hydrodynamic systems using a state-space representation, 
        considering only the vertical direction (1D model).</p>
        
        <p>Model Description:</p>
        <p>The radiation force is computed solely for the vertical direction (third element of the vectors) 
        based on the vertical velocity input. This simplification allows for efficient modeling of systems 
        where the primary concern is the vertical motion, such as in wave energy converters or floating structures.</p>
        
        <p>Inputs:</p>
        <ul>
          <li><code>z[3]</code>: Position vector [m] (currently not used in calculations, included for future extensions)</li>
          <li><code>v[3]</code>: Velocity vector [m/s] (only the third element, representing vertical velocity, is used)</li>
        </ul>
        
        <p>Outputs:</p>
        <ul>
          <li><code>y[3]</code>: Radiation force vector [N] (force applied only in the vertical direction, third element)</li>
        </ul>
        
        <p>Key Parameters:</p>
        <ul>
          <li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>: State-space model matrices and vectors for the 1D system</li>
          <li><code>enableRadiationForce</code>: Boolean switch to enable/disable the radiation force calculation</li>
        </ul>
        
        <p>Notes:</p>
        <ul>
          <li>The state-space model parameters (A, B, C, D) should be adjusted based on the specific 1D hydrodynamic system being modeled.</li>
          <li>This model assumes that the radiation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
          <li>The position input (z) is currently not used in the calculations but is included for potential future enhancements or compatibility with other models.</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "1D Rad F", fontName = "Arial")}));
    end RadiationF;

    model HydrodynamicBlock6D "6-Dimensional Hydrodynamic Forces and Moments Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.inputOutput_con;
      // Sensors
      // Hydrodynamic force components
      DragForce6D dragForce6D(Cdy = 0.01, rho = 1000, Cdx = 100, Cdz = 100, Crx = 100, Cry = 0.01, Crz = 100, enableDragForce = false) "Drag force calculation" annotation(
        Placement(transformation(origin = {18, 34}, extent = {{-10, -10}, {10, 10}})));
      PTO6D pto6d(enablePTOForce = false) "Power Take-Off force calculation" annotation(
        Placement(transformation(origin = {18, -46}, extent = {{-10, -10}, {10, 10}})));
      HydrostaticForce6D hydrostaticForce6D(enableHydrostaticForce = true) "Hydrostatic force calculation" annotation(
        Placement(transformation(origin = {16, -6}, extent = {{-10, -10}, {10, 10}})));
      RadiationF radiationF "Radiation force calculation" annotation(
        Placement(transformation(origin = {18, 66}, extent = {{-10, -10}, {10, 10}})));
    // Force and torque application components
      Sensors sensors annotation(
        Placement(transformation(origin = {-56, -4}, extent = {{-10, -10}, {10, 10}})));
    ForceToqueSum forceToqueSum annotation(
        Placement(transformation(origin = {60, 12}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {90, -52}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(frame_a, sensors.frame_a) annotation(
        Line(points = {{-102, 0}, {-66, 0}, {-66, -4}}));
      connect(sensors.u_abs, radiationF.z) annotation(
        Line(points = {{-44, 6}, {-42, 6}, {-42, 62}, {6, 62}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.v_abs, radiationF.v) annotation(
        Line(points = {{-44, -6}, {-30, -6}, {-30, 72}, {6, 72}, {6, 70}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.v_abs, dragForce6D.v_abs) annotation(
        Line(points = {{-44, -6}, {-22, -6}, {-22, 40}, {8, 40}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.omega_abs, dragForce6D.omega_abs) annotation(
        Line(points = {{-44, -12}, {-16, -12}, {-16, 28}, {8, 28}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.u_abs, hydrostaticForce6D.u_abs) annotation(
        Line(points = {{-44, 6}, {-2, 6}, {-2, 0}, {6, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.theta_abs, hydrostaticForce6D.theta_abs) annotation(
        Line(points = {{-46, 0}, {-2, 0}, {-2, -12}, {6, -12}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.v_abs, pto6d.v_abs) annotation(
        Line(points = {{-44, -6}, {-22, -6}, {-22, -40}, {8, -40}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.omega_abs, pto6d.omega_abs) annotation(
        Line(points = {{-44, -12}, {-44, -52}, {8, -52}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.u_abs, pto6d.u_abs) annotation(
        Line(points = {{-44, 6}, {-12, 6}, {-12, -38}, {6, -38}}, color = {0, 0, 127}, thickness = 0.5));
      connect(sensors.theta_abs, pto6d.theta_abs) annotation(
        Line(points = {{-46, 0}, {-30, 0}, {-30, -44}, {6, -44}}, color = {0, 0, 127}, thickness = 0.5));
    connect(radiationF.F, forceToqueSum.Fr) annotation(
        Line(points = {{30, 66}, {48, 66}, {48, 20}}, color = {0, 0, 127}, thickness = 0.5));
    connect(hydrostaticForce6D.F, forceToqueSum.Fhs) annotation(
        Line(points = {{28, -6}, {46, -6}, {46, 14}, {48, 14}}, color = {0, 0, 127}, thickness = 0.5));
    connect(dragForce6D.F, forceToqueSum.Fd) annotation(
        Line(points = {{18, 34}, {48, 34}, {48, 10}}));
    connect(pto6d.F, forceToqueSum.Fpto) annotation(
        Line(points = {{30, -46}, {48, -46}, {48, 4}}, color = {0, 0, 127}, thickness = 0.5));
    connect(forceToqueSum.T, forceAndTorque.torque) annotation(
        Line(points = {{70, 8}, {70, 6}, {78, 6}, {78, -46}}, color = {0, 0, 127}, thickness = 0.5));
    connect(forceToqueSum.F, forceAndTorque.force) annotation(
        Line(points = {{72, 18}, {72, 16}, {78, 16}, {78, -58}}, color = {0, 0, 127}, thickness = 0.5));
  connect(forceAndTorque.frame_b, frame_b) annotation(
        Line(points = {{100, -52}, {102, -52}, {102, 0}}));
      annotation(
        Diagram);
      annotation(
        Documentation(info = "<html>
        <p>This model calculates and applies 6-dimensional hydrodynamic forces and moments to a multibody system.</p>
        <p>It incorporates the following hydrodynamic effects:</p>
        <ul>
          <li>Drag forces and torques</li>
          <li>Power Take-Off (PTO) forces and torques</li>
          <li>Hydrostatic forces and torques</li>
          <li>Radiation forces</li>
        </ul>
        <p>The model uses absolute position, velocity, and angular sensors to determine the body's state, 
        calculates the various hydrodynamic forces, and applies them to the body.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>frame_a</code>: Input frame for body state</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>frame_b</code>: Output frame with applied hydrodynamic forces and torques</li>
        </ul>
        <p>Note: Some force components (e.g., drag and PTO) are disabled by default and can be enabled by modifying the respective parameters.</p>
      </html>"),
        Diagram);
    end HydrodynamicBlock6D;

    model BodyHD6D "6-Dimensional Hydrodynamic Body Model"
      extends Modelica.Blocks.Icons.Block;
      // MultiBody connectors
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Output frame" annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      // Body components
      Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape(height = 0.1, length = 0.1, m = 1958671, width = 0.1, r_CM = {0, 0, 0}, r = {0, 0, 0}) "Main body with mass and inertia" annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(r = {0, 0, 0}, animation = false) "Fixed translation to adjust body position" annotation(
        Placement(transformation(origin = {-20, 0}, extent = {{-10, -10}, {10, 10}})));
      // Hydrodynamic forces component
      HydrodynamicBlock6D hydrodynamicBlock6D "Calculation of hydrodynamic forces and moments" annotation(
        Placement(transformation(origin = {24, 34}, extent = {{-10, -10}, {10, 10}})));
    equation
// Connect input frame to body
      connect(frame_a, bodyShape.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
// Connect body to fixed translation
      connect(bodyShape.frame_b, fixedTranslation.frame_a) annotation(
        Line(points = {{-40, 0}, {-30, 0}}, color = {95, 95, 95}));
// Connect fixed translation to output frame
      connect(fixedTranslation.frame_b, frame_b) annotation(
        Line(points = {{-10, 0}, {102, 0}}, color = {95, 95, 95}));
// Connect hydrodynamic block to body
      connect(hydrodynamicBlock6D.frame_a, fixedTranslation.frame_b) annotation(
        Line(points = {{14, 34}, {-10, 34}, {-10, 0}}, color = {95, 95, 95}));
      connect(hydrodynamicBlock6D.frame_b, fixedTranslation.frame_b) annotation(
        Line(points = {{34, 34}, {46, 34}, {46, 0}, {-10, 0}}, color = {95, 95, 95}));
      annotation(
        Documentation(info = "<html>
        <p>This model represents a 6-dimensional hydrodynamic body, incorporating both rigid body dynamics and hydrodynamic forces.</p>
        <p>The model consists of:</p>
        <ul>
          <li>A main body with specified mass and inertia</li>
          <li>A fixed translation component to adjust the body's position</li>
          <li>A hydrodynamic block that calculates and applies various hydrodynamic forces and moments</li>
        </ul>
        <p>Inputs:</p>
        <ul>
          <li><code>frame_a</code>: Input frame for external connections</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>frame_b</code>: Output frame for external connections</li>
        </ul>
        <p>The hydrodynamic forces are applied to the body through the HydrodynamicBlock6D component, 
        which calculates drag, power take-off, hydrostatic, and radiation forces based on the body's motion.</p>
        <p>Note: The body's shape parameters (height, length, width) and mass can be adjusted as needed for specific applications.</p>
      </html>"),
        Icon(graphics = {Text(origin = {-2, -95}, extent = {{-58, 15}, {62, -5}}, textString = "Rigid Body 6D"), Rectangle(origin = {3, -10}, fillColor = {211, 215, 207}, fillPattern = FillPattern.Solid, extent = {{-95, 50}, {89, -50}}), Text(origin = {0, 54}, extent = {{-100, 16}, {100, -24}}, textString = "%name")}));
    end BodyHD6D;

    model ExcitationForce "1D Excitation Force Model for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      // Output connector
      Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
        Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      // Import the CombiTimeTable for data input
      import Modelica.Blocks.Sources.CombiTimeTable;
      // Excitation force data input
      CombiTimeTable excitationData(tableOnFile = true, fileName = "C:/Users/Duke/SysModel2024/DragSystem/ExcF9.csv", tableName = "excitation", columns = {2}, extrapolation = Modelica.Blocks.Types.Extrapolation.HoldLastPoint) "Time series data for vertical excitation force";
    equation
// Apply excitation force only in the vertical direction (third element)
      y = {0, 0, excitationData.y[1]};
      annotation(
        Documentation(info = "<html>
        <h4>1D Excitation Force Model for Hydrodynamic Systems</h4>
        <p>This model represents the excitation force for hydrodynamic systems, 
        considering only the vertical direction (1D model).</p>
        
        <p>Model Description:</p>
        <p>The excitation force is applied solely in the vertical direction (third element of the output vector). 
        The force magnitude is obtained from a time series data file, allowing for the representation of 
        time-varying excitation forces such as those caused by waves in marine applications.</p>
        
        <p>Inputs:</p>
        <ul>
          <li>No direct inputs. The excitation force is read from an external CSV file.</li>
        </ul>
        
        <p>Outputs:</p>
        <ul>
          <li><code>y[3]</code>: Excitation force vector [N] (force applied only in the vertical direction, third element)</li>
        </ul>
        
        <p>Key Components:</p>
        <ul>
          <li><code>excitationData</code>: CombiTimeTable that reads the excitation force data from a CSV file</li>
        </ul>
        
        <p>File Input:</p>
        <ul>
          <li>File path: C:/Users/Duke/SysModel2024/DragSystem/ExcF6.csv</li>
          <li>Table name: 'excitation'</li>
          <li>Only the second column of the CSV file is used (assumed to contain force values)</li>
        </ul>
        
        <p>Notes:</p>
        <ul>
          <li>The model assumes that the excitation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
          <li>The excitation force data is held at its last value if the simulation time exceeds the data in the input file.</li>
          <li>Ensure that the CSV file path is correct and the file is accessible for successful simulation.</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "1D Exc F", fontName = "Arial")}));
    end ExcitationForce;
    annotation(
      Documentation(info = "<html>
      <h4>Forces Package for Hydrodynamic Systems</h4>
      <p>This package contains various force models used in hydrodynamic systems simulations, particularly for marine and offshore applications.</p>
      <p>Included models:</p>
      <ul>
        <li><b>DragForce6D:</b> 6D drag force and torque calculation, accounting for both linear and angular velocities</li>
        <li><b>PTO6D:</b> 6D power take-off system, simulating energy extraction in wave energy converters</li>
        <li><b>HydrostaticForce6D:</b> 6D hydrostatic force and torque calculation, representing buoyancy and stability</li>
        <li><b>RadiationF:</b> 1D radiation force calculation, modeling energy dissipation due to wave generation</li>
        <li><b>ExcitationForce:</b> 1D excitation force model, representing incident wave forces on floating structures</li>
      </ul>
      <p>These models can be used individually or combined to create complex hydrodynamic simulations for applications such as:</p>
      <ul>
        <li>Wave energy converters</li>
        <li>Floating offshore wind turbines</li>
        <li>Marine vessels and structures</li>
        <li>Underwater vehicles</li>
      </ul>
      <p>Each model is thoroughly documented and includes customizable parameters to adapt to various scenarios and environmental conditions.</p>
    </html>"),
      Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 0}, fillColor = {215, 235, 255}, fillPattern = FillPattern.Solid), Line(points = {{-80, -80}, {-80, 60}, {-60, 80}, {60, 80}, {80, 60}, {80, -80}}, color = {0, 0, 0}, thickness = 0.5), Line(points = {{-60, -80}, {-40, -60}, {-20, -80}, {0, -60}, {20, -80}, {40, -60}, {60, -80}}, color = {0, 70, 150}, thickness = 1), Polygon(points = {{-40, 40}, {0, 60}, {40, 40}, {0, 20}, {-40, 40}}, lineColor = {0, 0, 0}, fillColor = {170, 213, 255}, fillPattern = FillPattern.Solid), Line(points = {{0, 60}, {0, -10}}, color = {0, 0, 0}), Ellipse(extent = {{-6, -4}, {6, -16}}, lineColor = {0, 0, 0}, fillColor = {255, 0, 0}, fillPattern = FillPattern.Solid), Line(points = {{-80, 0}, {80, 0}}, color = {0, 0, 0}, pattern = LinePattern.Dot), Text(extent = {{-100, -90}, {100, -120}}, lineColor = {0, 0, 0}, fillColor = {215, 235, 255}, fillPattern = FillPattern.Solid, textString = "%name")}));
  end Forces;

  package WaveProfile
    package RegularWave
      /* Package for regular wave elevation profile and excitation force calculations */

      model LinearWave "Implementation of linear Airy wave model with excitation force calculation"
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        // Output connector for excitation force
        Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
          Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})),
          Documentation(info = "<html>
            <p>Output connector for the calculated excitation force. Only the vertical component (3rd element) is non-zero.</p>
          </html>"));
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Environmental constants
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // File input parameters
        parameter String fileName = "C:/Users/Duke/SysModel2024/OET_Sys-MoDEL/tutorial/hydroCoeff.mat" "Path to the hydroCoeff.mat file" annotation(
          Dialog(group = "File Input"));
        parameter Integer wDims[:] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.w") "Dimensions of the frequency vector";
        parameter Integer wSize = wDims[2] "Size of the frequency vector";
        parameter Real F_excRe[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcRe", 1, wSize)) "Real part of excitation force coefficients";
        parameter Real F_excIm[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcIm", 1, wSize)) "Imaginary part of excitation force coefficients";
        parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.w", 1, wSize)) "Angular frequency vector [rad/s]";
        // Wave parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega = 0.9423 "Wave frequency [rad/s]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Real Trmp = 50 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Wave Parameters"));
        // Derived parameters
        parameter Modelica.Units.SI.Length zeta = Hs/2 "Wave amplitude [m]";
        parameter Real Tp = 2*pi/omega "Wave period [s]";
        parameter Real k = 2*pi/(1.56*(Tp^2)) "Wave number [1/m]";
        // Variables
        Real ExcCoeffRe "Real component of excitation coefficient";
        Real ExcCoeffIm "Imaginary component of excitation coefficient";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for the given wave frequency
        ExcCoeffRe = Modelica.Math.Vectors.interpolate(w, F_excRe, omega);
        ExcCoeffIm = Modelica.Math.Vectors.interpolate(w, F_excIm, omega);
// Define wave elevation profile (SSE)
        SSE = zeta*cos(omega*time);
// Calculate and apply ramping to the excitation force
        if time < Trmp then
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
        else
          wconn.F_exc = ((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
        end if;
// Assign excitation force to output (vertical component only)
        y = {0, 0, wconn.F_exc};
        annotation(
          Documentation(info = "<html>
            <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          </html>"),
          Icon(graphics = {Line(origin = {-50.91, 48.08}, points = {{-33.2809, -22.5599}, {-21.2809, -20.5599}, {-13.2809, 27.4401}, {6.71907, -20.5599}, {24.7191, -24.5599}, {42.7191, -24.5599}, {44.7191, -24.5599}}, color = {255, 0, 0}, smooth = Smooth.Bezier), Line(origin = {-37, 51}, points = {{-51, 29}, {-51, -29}, {37, -29}}), Text(origin = {6, 55}, extent = {{-40, 17}, {40, -17}}, textString = "Hs"), Line(origin = {22, 4}, points = {{0, 22}, {0, -22}}, thickness = 1, arrow = {Arrow.None, Arrow.Filled}), Line(origin = {-7.57, -61.12}, points = {{-82.4341, -12.8774}, {-76.4341, -2.87735}, {-72.4341, -6.87735}, {-62.4341, 13.1226}, {-50.4341, -26.8774}, {-46.4341, -20.8774}, {-38.4341, -26.8774}, {-34.4341, -18.8774}, {-34.4341, 3.12265}, {-26.4341, 1.12265}, {-20.4341, 7.12265}, {-12.4341, 9.12265}, {-8.43408, 19.1226}, {1.56592, -4.87735}, {7.56592, -24.8774}, {19.5659, -6.87735}, {21.5659, 9.12265}, {31.5659, 13.1226}, {39.5659, -0.87735}, {43.5659, 11.1226}, {55.5659, 15.1226}, {63.5659, 27.1226}, {79.5659, -22.8774}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Rectangle(origin = {100, 0}, fillColor = {85, 255, 127}, fillPattern = FillPattern.Solid, extent = {{-20, 20}, {20, -20}})}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end LinearWave;
      annotation(
        Documentation(info = "<html>
          <p>This package contains models for generating regular wave profiles and calculating associated excitation forces.</p>
          <p>The package currently includes:</p>
          <ul>
            <li>LinearWave: A model implementing the linear Airy wave theory</li>
          </ul>
        </html>"),
        Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {230, 230, 250}, fillPattern = FillPattern.Solid), Line(points = {{-80, 60}, {-40, 80}, {0, 60}, {40, 80}, {80, 60}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Line(points = {{-80, 20}, {-40, 40}, {0, 20}, {40, 40}, {80, 20}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Line(points = {{-80, -20}, {-40, 0}, {0, -20}, {40, 0}, {80, -20}}, color = {0, 0, 255}, smooth = Smooth.Bezier)}));
    end RegularWave;

    package IrregularWave
      /* Package for irregular wave elevation profile and excitation force calculations */

      model PiersonMoskowitzWave "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
          Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})),
          Documentation(info = "<html>
            <p>Output connector for the calculated excitation force. Only the vertical component (3rd element) is non-zero.</p>
          </html>"));
        // Environmental constants
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // File input parameters
        parameter String fileName =    
        "C:/Users/Thomas/Documents/GitHub/6-DoF-Hydrodynamics/hydroCoeff.mat" "Path to the hydroCoeff.mat file" annotation(
          Dialog(group = "File Input"));
        
        parameter Integer wDims[:] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.w") "Dimensions of the frequency vector";
        parameter Integer wSize = wDims[2] "Size of the frequency vector";
        parameter Real F_excRe[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcRe", 1, wSize)) "Real part of excitation force coefficients";
        parameter Real F_excIm[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcIm", 1, wSize)) "Imaginary part of excitation force coefficients";
        parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.w", 1, wSize)) "Angular frequency vector [rad/s]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 100 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_PM(Hs, omega) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
// Assign excitation force to output (vertical component only)
        y = {0, 0, wconn.F_exc};
        annotation(
          Documentation(info = "<html>
            <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
            <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the PM formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(origin = {-50.91, 48.08}, points = {{-33.2809, -22.5599}, {-21.2809, -20.5599}, {-13.2809, 27.4401}, {6.71907, -20.5599}, {24.7191, -24.5599}, {42.7191, -24.5599}, {44.7191, -24.5599}}, color = {255, 0, 0}, smooth = Smooth.Bezier), Line(origin = {-37, 51}, points = {{-51, 29}, {-51, -29}, {37, -29}}), Text(origin = {6, 55}, extent = {{-40, 17}, {40, -17}}, textString = "Hs"), Line(origin = {22, 4}, points = {{0, 22}, {0, -22}}, thickness = 1, arrow = {Arrow.None, Arrow.Filled}), Line(origin = {-7.57, -61.12}, points = {{-82.4341, -12.8774}, {-76.4341, -2.87735}, {-72.4341, -6.87735}, {-62.4341, 13.1226}, {-50.4341, -26.8774}, {-46.4341, -20.8774}, {-38.4341, -26.8774}, {-34.4341, -18.8774}, {-34.4341, 3.12265}, {-26.4341, 1.12265}, {-20.4341, 7.12265}, {-12.4341, 9.12265}, {-8.43408, 19.1226}, {1.56592, -4.87735}, {7.56592, -24.8774}, {19.5659, -6.87735}, {21.5659, 9.12265}, {31.5659, 13.1226}, {39.5659, -0.87735}, {43.5659, 11.1226}, {55.5659, 15.1226}, {63.5659, 27.1226}, {79.5659, -22.8774}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Rectangle(origin = {100, 0}, fillColor = {85, 255, 127}, fillPattern = FillPattern.Solid, extent = {{-20, 20}, {20, -20}})}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end PiersonMoskowitzWave;

      model BretschneiderWave "Implementation of Bretschneider wave spectrum for irregular wave generation"
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
          Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
        // Environmental constants
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // File input parameters
        parameter String fileName = "C:/Users/Duke/SysModel2024/OET_Sys-MoDEL/tutorial/hydroCoeff.mat" "Path to the hydroCoeff.mat file" annotation(
          Dialog(group = "File Input"));
        parameter Integer wDims[:] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.w") "Dimensions of the frequency vector";
        parameter Integer wSize = wDims[2] "Size of the frequency vector";
        parameter Real F_excRe[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcRe", 1, wSize)) "Real part of excitation force coefficients";
        parameter Real F_excIm[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcIm", 1, wSize)) "Imaginary part of excitation force coefficients";
        parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.w", 1, wSize)) "Angular frequency vector [rad/s]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_BRT(Hs, omega, omega_peak) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
// Assign excitation force to output (vertical component only)
        y = {0, 0, wconn.F_exc};
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(origin = {-50.91, 48.08}, points = {{-33.2809, -22.5599}, {-21.2809, -20.5599}, {-13.2809, 27.4401}, {6.71907, -20.5599}, {24.7191, -24.5599}, {42.7191, -24.5599}, {44.7191, -24.5599}}, color = {255, 0, 0}, smooth = Smooth.Bezier), Line(origin = {-37, 51}, points = {{-51, 29}, {-51, -29}, {37, -29}}), Text(origin = {6, 55}, extent = {{-40, 17}, {40, -17}}, textString = "Hs"), Line(origin = {22, 4}, points = {{0, 22}, {0, -22}}, thickness = 1, arrow = {Arrow.None, Arrow.Filled}), Line(origin = {-7.57, -61.12}, points = {{-82.4341, -12.8774}, {-76.4341, -2.87735}, {-72.4341, -6.87735}, {-62.4341, 13.1226}, {-50.4341, -26.8774}, {-46.4341, -20.8774}, {-38.4341, -26.8774}, {-34.4341, -18.8774}, {-34.4341, 3.12265}, {-26.4341, 1.12265}, {-20.4341, 7.12265}, {-12.4341, 9.12265}, {-8.43408, 19.1226}, {1.56592, -4.87735}, {7.56592, -24.8774}, {19.5659, -6.87735}, {21.5659, 9.12265}, {31.5659, 13.1226}, {39.5659, -0.87735}, {43.5659, 11.1226}, {55.5659, 15.1226}, {63.5659, 27.1226}, {79.5659, -22.8774}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Rectangle(origin = {100, 0}, fillColor = {85, 255, 127}, fillPattern = FillPattern.Solid, extent = {{-20, 20}, {20, -20}})}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end BretschneiderWave;

      model JonswapWave "Implementation of JONSWAP wave spectrum for irregular wave generation"
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
          Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})),
          Documentation(info = "<html>
            <p>Output connector for the calculated excitation force. Only the vertical component (3rd element) is non-zero.</p>
          </html>"));
        // Environmental constants
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // File input parameters
        parameter String fileName = "C:/Users/Duke/SysModel2024/OET_Sys-MoDEL/tutorial/hydroCoeff.mat" "Path to the hydroCoeff.mat file" annotation(
          Dialog(group = "File Input"));
        parameter Integer wDims[:] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.w") "Dimensions of the frequency vector";
        parameter Integer wSize = wDims[2] "Size of the frequency vector";
        parameter Real F_excRe[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcRe", 1, wSize)) "Real part of excitation force coefficients";
        parameter Real F_excIm[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcIm", 1, wSize)) "Imaginary part of excitation force coefficients";
        parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.w", 1, wSize)) "Angular frequency vector [rad/s]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
// Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
// Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
// Calculate and apply ramping to the excitation force
        if time < Trmp then
// Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
// Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
// Assign excitation force to output (vertical component only)
        y = {0, 0, wconn.F_exc};
        annotation(
          Documentation(info = "<html>
            <h4>JONSWAP Wave Spectrum Model</h4>
            <p>This model implements the JONSWAP (Joint North Sea Wave Project) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the JONSWAP formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
              <li>JONSWAP spectrum is particularly suitable for modeling developing seas and storm conditions</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(origin = {-50.91, 48.08}, points = {{-33.2809, -22.5599}, {-21.2809, -20.5599}, {-13.2809, 27.4401}, {6.71907, -20.5599}, {24.7191, -24.5599}, {42.7191, -24.5599}, {44.7191, -24.5599}}, color = {255, 0, 0}, smooth = Smooth.Bezier), Line(origin = {-37, 51}, points = {{-51, 29}, {-51, -29}, {37, -29}}), Text(origin = {6, 55}, extent = {{-40, 17}, {40, -17}}, textString = "Hs"), Line(origin = {22, 4}, points = {{0, 22}, {0, -22}}, thickness = 1, arrow = {Arrow.None, Arrow.Filled}), Line(origin = {-7.57, -61.12}, points = {{-82.4341, -12.8774}, {-76.4341, -2.87735}, {-72.4341, -6.87735}, {-62.4341, 13.1226}, {-50.4341, -26.8774}, {-46.4341, -20.8774}, {-38.4341, -26.8774}, {-34.4341, -18.8774}, {-34.4341, 3.12265}, {-26.4341, 1.12265}, {-20.4341, 7.12265}, {-12.4341, 9.12265}, {-8.43408, 19.1226}, {1.56592, -4.87735}, {7.56592, -24.8774}, {19.5659, -6.87735}, {21.5659, 9.12265}, {31.5659, 13.1226}, {39.5659, -0.87735}, {43.5659, 11.1226}, {55.5659, 15.1226}, {63.5659, 27.1226}, {79.5659, -22.8774}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Rectangle(origin = {100, 0}, fillColor = {85, 255, 127}, fillPattern = FillPattern.Solid, extent = {{-20, 20}, {20, -20}})}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end JonswapWave;
      annotation(
        Documentation(info = "<html>
      <p><strong>IrregularWave Package</strong></p>
      <p>This package provides models for generating irregular wave profiles and calculating associated excitation forces using various wave spectra commonly used in ocean engineering and naval architecture.</p>
      <p><em>Included Models:</em></p>
      <ul>
        <p><strong>PiersonMoskowitzWave:</strong> Implements the Pierson-Moskowitz spectrum, suitable for fully developed seas.</p>
        <p><strong>BretschneiderWave:</strong> Implements the Bretschneider spectrum, a two-parameter spectrum also known as the modified Pierson-Moskowitz spectrum.</p>
        <p><strong>JonswapWave:</strong> Implements the JONSWAP (Joint North Sea Wave Project) spectrum, particularly useful for modeling developing seas and storm conditions.</p>
      </ul>
      <p>These models enable realistic simulation of ocean conditions for various marine engineering applications, including:</p>
      <ul>
        <p>- Offshore structure design and analysis</p>
        <p>- Wave energy converter performance evaluation</p>
        <p>- Ship motion studies</p>
        <p>- Coastal engineering projects</p>
      </ul>
      <p>Each model provides options for customizing sea state parameters and offers both wave elevation profiles and excitation force calculations.</p>
    </html>"),
        Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {230, 230, 250}, fillPattern = FillPattern.Solid), Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-90, -70}, {90, -90}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "Irregular Wave"), Ellipse(extent = {{-15, 15}, {15, -15}}, lineColor = {255, 255, 0}, fillColor = {255, 255, 0}, fillPattern = FillPattern.Solid, origin = {-75, 75}), Line(points = {{-65, 65}, {-55, 55}}, color = {255, 255, 0}, thickness = 1.5), Line(points = {{-75, 60}, {-75, 50}}, color = {255, 255, 0}, thickness = 1.5), Line(points = {{-85, 65}, {-95, 55}}, color = {255, 255, 0}, thickness = 1.5)}));
    end IrregularWave;
    annotation(
      Documentation(info = "<html>
      <p><strong>WaveProfile Package</strong></p>
      <p>This package provides comprehensive models for generating wave profiles and calculating associated excitation forces for both regular and irregular waves. It is designed for use in ocean engineering, naval architecture, and offshore structure analysis.</p>
      
      <p><strong>Package Contents:</strong></p>
      <p><strong>1. RegularWave</strong></p>
      <ul>
        <li><strong>LinearWave:</strong> Implements the linear Airy wave theory for regular waves.</li>
      </ul>
      
      <p><strong>2. IrregularWave</strong></p>
      <ul>
        <li><strong>PiersonMoskowitzWave:</strong> Generates irregular waves using the Pierson-Moskowitz spectrum, suitable for fully developed seas.</li>
        <li><strong>BretschneiderWave:</strong> Implements the Bretschneider (modified Pierson-Moskowitz) spectrum for more flexible sea state modeling.</li>
        <li><strong>JonswapWave:</strong> Uses the JONSWAP spectrum, ideal for modeling developing seas and storm conditions.</li>
      </ul>
      
      <p><strong>Key Features:</strong></p>
      <ul>
        <li>Calculation of wave elevation profiles</li>
        <li>Computation of wave-induced excitation forces</li>
        <li>Customizable sea state parameters</li>
        <li>Support for both deterministic (regular) and stochastic (irregular) wave modeling</li>
      </ul>
      
      <p>This package is essential for various marine engineering applications, including offshore structure design, wave energy converter analysis, ship motion studies, and coastal engineering projects.</p>
    </html>"),
      Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {230, 240, 255}, fillPattern = FillPattern.Solid), // Regular wave representation
      Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), // Irregular wave representation
      Line(points = {{-90, -40}, {-75, -20}, {-60, -50}, {-45, -30}, {-30, -60}, {-15, -25}, {0, -55}, {15, -35}, {30, -65}, {45, -20}, {60, -50}, {75, -30}, {90, -60}}, color = {0, 100, 255}, thickness = 2, smooth = Smooth.Bezier), // Sun symbol
      Ellipse(extent = {{-20, 90}, {20, 50}}, lineColor = {255, 215, 0}, fillColor = {255, 215, 0}, fillPattern = FillPattern.Solid), Line(points = {{-30, 70}, {30, 70}}, color = {255, 215, 0}, thickness = 2), Line(points = {{-20, 85}, {20, 55}}, color = {255, 215, 0}, thickness = 2), Line(points = {{-20, 55}, {20, 85}}, color = {255, 215, 0}, thickness = 2), // Text
      Text(extent = {{-90, -70}, {90, -95}}, lineColor = {0, 0, 255}, textString = "Wave Profile", fontSize = 14)}));
  end WaveProfile;

  package Internal
    /* Internal library of core functions and connectors for ocean engineering applications
           This package contains essential components for wave modeling and structure interactions */

    package Functions
      /* Package defining explicit library functions for wave calculations and random number generation
               This package contains a collection of functions essential for ocean engineering simulations,
               including wave number calculations, random number generation, and various wave spectrum generators. */

      function waveNumber "Function to iteratively compute the wave number from frequency components"
        /* Uses the dispersion relationship for water waves to calculate wave numbers
                   This function implements an iterative method to solve the implicit dispersion equation */
        input Real d "Water depth [m]";
        input Real omega[:] "Array of wave frequency components [rad/s]";
        output Real k[size(omega, 1)] "Array of wave number components [rad/m]";
      protected
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        parameter Integer n = size(omega, 1) "Number of frequency components";
        Real T[size(omega, 1)] "Array of wave period components [s]";
        Real L0[size(omega, 1)] "Array of deepwater wavelength components [m]";
        Real L1(start = 0, fixed = true) "Temporary variable for wavelength iteration [m]";
        Real L1c(start = 0, fixed = true) "Temporary variable for wavelength iteration comparison [m]";
        Real L[size(omega, 1)] "Array of iterated wavelength components [m]";
      algorithm
        T := 2*pi./omega;
        L0 := g*T.^2/(2*pi);
        for i in 1:size(omega, 1) loop
          L1 := L0[i];
          L1c := 0;
          while abs(L1c - L1) > 0.001 loop
            L1c := L1;
            L[i] := g*T[i]^2/(2*pi)*tanh(2*pi/L1*d);
            L1 := L[i];
          end while;
        end for;
        k := 2*pi./L;
        annotation(
          Documentation(info = "<html>
            <p>Syntax: k = waveNumber(d, omega)</p>
            <p>Description: This function calculates wave numbers for given frequencies and water depth using the dispersion relationship for water waves. It employs an iterative method to solve the implicit dispersion equation.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>d</code>: Water depth [m]</li>
              <li><code>omega</code>: Array of wave frequency components [rad/s]</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>k</code>: Array of wave number components [rad/m]</li>
            </ul>
            <p>Algorithm:</p>
            <ol>
              <li>Calculate wave periods from frequencies</li>
              <li>Calculate deepwater wavelengths</li>
              <li>Iterate to solve the dispersion equation for each frequency component</li>
              <li>Convert wavelengths to wave numbers</li>
            </ol>
          </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "k(ω)", textStyle = {TextStyle.Bold}), Line(points = {{-80, -80}, {80, 80}}, color = {0, 0, 255}, thickness = 0.5)}),
          Diagram(graphics = {Text(extent = {{-100, 80}, {100, 40}}, textString = "Wave Number Calculation"), Line(points = {{-80, 0}, {80, 0}}, color = {0, 0, 255}), Line(points = {{0, -80}, {0, 80}}, color = {0, 0, 255}), Text(extent = {{-60, -20}, {60, -60}}, textString = "k = 2π/L")}),
          experiment(StopTime = 1.0, Tolerance = 1e-06));
      end waveNumber;

      function randomNumberGen "Function to generate random numbers using XOR shift algorithm"
        /* Produces a vector of random numbers based on local and global seeds
                 This function utilizes the Xorshift64star algorithm for efficient random number generation */
        input Integer ls = 614657 "Local seed for random number generation";
        input Integer gs = 30020 "Global seed for random number generation";
        input Integer n = 100 "Number of random numbers to generate";
        output Real r64[n] "Vector of generated random numbers";
      protected
        Integer state64[2](each start = 0, each fixed = true) "State vector for XOR shift algorithm";
      algorithm
        state64[1] := 0;
        state64[2] := 0;
        for i in 1:n loop
          if i == 1 then
            state64 := Modelica.Math.Random.Generators.Xorshift64star.initialState(ls, gs);
            r64[i] := 0;
          else
            (r64[i], state64) := Modelica.Math.Random.Generators.Xorshift64star.random((state64));
          end if;
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: r64 = randomNumberGen(ls, gs, n)</p>
          <p>Description: This function generates a vector of random numbers using the Xorshift64star algorithm, which is known for its efficiency and good statistical properties.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>ls</code>: Local seed for random number generation (default: 614657)</li>
            <li><code>gs</code>: Global seed for random number generation (default: 30020)</li>
            <li><code>n</code>: Number of random numbers to generate (default: 100)</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>r64</code>: Vector of generated random numbers</li>
          </ul>
          <p>Algorithm: The function uses the Xorshift64star algorithm to generate random numbers based on the provided seeds.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "RNG", textStyle = {TextStyle.Bold})}));
      end randomNumberGen;

      function frequencySelector "Function to randomly select frequency components within a specified range"
        /* Uses a random phase vector to perturb frequencies
                 This function ensures a good distribution of frequencies for irregular wave generation */
        input Real omega_min "Minimum frequency [rad/s]";
        input Real omega_max "Maximum frequency [rad/s]";
        input Real epsilon[:] "Random phase vector for frequency perturbation";
        output Real omega[size(epsilon, 1)] "Output vector of selected frequency components [rad/s]";
      protected
        parameter Real ref_omega[size(epsilon, 1)] = omega_min:(omega_max - omega_min)/(size(epsilon, 1) - 1):omega_max "Reference frequency vector [rad/s]";
      algorithm
        omega[1] := omega_min;
        for i in 2:size(epsilon, 1) - 1 loop
          omega[i] := ref_omega[i] + epsilon[i]*omega_min;
        end for;
        omega[size(epsilon, 1)] := omega_max;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: omega = frequencySelector(omega_min, omega_max, epsilon)</p>
          <p>Description: This function selects frequency components within a specified range, using a random phase vector to perturb the frequencies. This ensures a good distribution of frequencies for irregular wave generation.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>omega_min</code>: Minimum frequency [rad/s]</li>
            <li><code>omega_max</code>: Maximum frequency [rad/s]</li>
            <li><code>epsilon</code>: Random phase vector for frequency perturbation</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>omega</code>: Output vector of selected frequency components [rad/s]</li>
          </ul>
          <p>Algorithm: The function creates a reference frequency vector and then perturbs it using the random phase vector, ensuring the first and last frequencies are exactly omega_min and omega_max.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "ω(ε)", textStyle = {TextStyle.Bold})}));
      end frequencySelector;

      function spectrumGenerator_PM "Function to generate Pierson-Moskowitz spectrum"
        /* Calculates spectral values for given frequencies based on significant wave height
                 This function implements the Pierson-Moskowitz spectrum, suitable for fully developed seas */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
      algorithm
        for i in 1:size(omega, 1) loop
          spec[i] := 0.0081*g^2/omega[i]^5*exp(-0.0358*(g/(Hs*omega[i]^2))^2);
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_PM(Hs, omega)</p>
          <p>Description: This function generates the Pierson-Moskowitz spectrum, which is suitable for fully developed seas. It calculates spectral values for given frequencies based on the significant wave height.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the Pierson-Moskowitz formula: S(ω) = 0.0081*g^2/ω^5 * exp(-0.0358*(g/(Hs*ω^2))^2)</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "PM", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_PM;

      function spectrumGenerator_BRT "Function to generate Bretschneider spectrum"
        /* Calculates spectral values based on significant wave height and peak frequency
                 This function implements the Bretschneider spectrum, a two-parameter spectrum for fetch-limited seas */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
      algorithm
        for i in 1:size(omega, 1) loop
          spec[i] := 1.9635*Hs^2*omega_peak^4/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4));
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_BRT(Hs, omega, omega_peak)</p>
          <p>Description: This function generates the Bretschneider spectrum, which is a two-parameter spectrum suitable for fetch-limited seas. It calculates spectral values based on significant wave height and peak frequency.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
            <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the Bretschneider formula: S(ω) = 1.9635*Hs^2*ω_peak^4/ω^5 * exp(-1.25*((ω_peak/ω)^4))</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "BRT", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_BRT;

      function spectrumGenerator_JONSWAP "Function to generate JONSWAP (Joint North Sea Wave Project) spectrum"
        /* Calculates spectral values based on significant wave height, peak frequency, and spectral width parameters
                 This function implements the JONSWAP spectrum, suitable for developing seas with fetch limitations */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
        input Real spectralWidth_min "Minimum spectral width parameter";
        input Real spectralWidth_max "Maximum spectral width parameter";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        constant Real gamma = 3.3 "Peak enhancement factor for JONSWAP spectrum";
        Real sigma "Spectral width parameter";
        Real b "Exponent for peak enhancement factor";
      algorithm
        for i in 1:size(omega, 1) loop
          if omega[i] > omega_peak then
            sigma := spectralWidth_max;
          else
            sigma := spectralWidth_min;
          end if;
          b := exp(-0.5*(((omega[i] - omega_peak)/(sigma*omega_peak))^2));
          spec[i] := 0.0081*g^2/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4))*gamma^b;
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max)</p>
          <p>Description: This function generates the JONSWAP (Joint North Sea Wave Project) spectrum, which is suitable for developing seas with fetch limitations. It calculates spectral values based on significant wave height, peak frequency, and spectral width parameters.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
            <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
            <li><code>spectralWidth_min</code>: Minimum spectral width parameter</li>
            <li><code>spectralWidth_max</code>: Maximum spectral width parameter</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the JONSWAP formula, which is an extension of the Pierson-Moskowitz spectrum with additional parameters to account for fetch-limited seas.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "JONSWAP", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_JONSWAP;
      annotation(
        Documentation(info = "<html>
          <p>This package contains a set of functions essential for ocean engineering simulations:</p>
          <ul>
            <li><b>waveNumber:</b> Calculates wave numbers using the dispersion relationship</li>
            <li><b>randomNumberGen:</b> Generates random numbers using the XOR shift algorithm</li>
            <li><b>frequencySelector:</b> Selects frequency components for irregular wave generation</li>
            <li><b>spectrumGenerator_PM:</b> Generates Pierson-Moskowitz spectrum</li>
            <li><b>spectrumGenerator_BRT:</b> Generates Bretschneider spectrum</li>
            <li><b>spectrumGenerator_JONSWAP:</b> Generates JONSWAP spectrum</li>
          </ul>
          <p>These functions provide the core calculations needed for wave modeling and analysis in ocean engineering applications.</p>
        </html>"),
        Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {215, 215, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 90}, {90, 50}}, lineColor = {0, 0, 0}, textString = "f(x)"), Line(points = {{-80, -20}, {-60, 20}, {-40, -40}, {-20, 40}, {0, -20}, {20, 60}, {40, -60}, {60, 20}, {80, -40}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Text(extent = {{-90, -50}, {90, -90}}, lineColor = {0, 0, 0}, textString = "Functions")}));
    end Functions;

    package Connectors
      /* Package defining library connectors for data exchange between components */

      connector WaveOutConn "Output connector for wave data"
        Modelica.Blocks.Interfaces.RealOutput F_exc "Excitation force [N]";
      end WaveOutConn;

      connector WaveInConn "Input connector for wave data"
        Modelica.Blocks.Interfaces.RealInput F_exc "Excitation force [N]";
      end WaveInConn;

      connector DataCollector "Output connector for collecting simulation data"
        Modelica.Blocks.Interfaces.RealOutput F_rad "Radiation force [N]";
        Modelica.Blocks.Interfaces.RealOutput v_z "Vertical velocity [m/s]";
      end DataCollector;
    end Connectors;

    model TestDevelopment "Model to test all wave components and WEC rigid body interactions"
      /* Demonstrates the use of different wave types and their connections to rigid body models */
      parameter String filePath = "F:/.../hydroCoeff.mat" "File path for hydrodynamic coefficients";
      // Wave models
      Hydrodynamic.WaveProfile.RegularWave.LinearWave Reg1(fileName = filePath, Hs = 2.5, Trmp = 50) "Regular linear wave model";
      Hydrodynamic.WaveProfile.IrregularWave.PiersonMoskowitzWave Irr1(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular Pierson-Moskowitz wave model";
      Hydrodynamic.WaveProfile.IrregularWave.BretschneiderWave Irr2(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular Bretschneider wave model";
      Hydrodynamic.WaveProfile.IrregularWave.JonswapWave Irr3(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular JONSWAP wave model";
      // Rigid body models
      Hydrodynamic.Structures.RigidBody Body1(fileName = filePath) "Rigid body for regular wave interaction";
      Hydrodynamic.Structures.RigidBody Body2(fileName = filePath) "Rigid body for Pierson-Moskowitz wave interaction";
      Hydrodynamic.Structures.RigidBody Body3(fileName = filePath) "Rigid body for Bretschneider wave interaction";
      Hydrodynamic.Structures.RigidBody Body4(fileName = filePath) "Rigid body for JONSWAP wave interaction";
    equation
// Connect wave models to corresponding rigid bodies
      connect(Reg1.wconn.F_exc, Body1.wconn.F_exc) "Connection for regular wave excitation";
      connect(Irr1.wconn.F_exc, Body2.wconn.F_exc) "Connection for Pierson-Moskowitz wave excitation";
      connect(Irr2.wconn.F_exc, Body3.wconn.F_exc) "Connection for Bretschneider wave excitation";
      connect(Irr3.wconn.F_exc, Body4.wconn.F_exc) "Connection for JONSWAP wave excitation";
      annotation(
        experiment(StartTime = 0, StopTime = 200, Tolerance = 1e-06, Interval = 0.1),
        Documentation(info = "<html>
          <p>This model demonstrates the interaction between different wave types and rigid body structures.</p>
          <p>It includes regular and irregular wave models connected to corresponding rigid body models for simulation.</p>
        </html>"));
    end TestDevelopment;
    annotation(
      Documentation(info = "<html>
        <p>This package contains internal functions, connectors, and test models for the Ocean Engineering Toolbox.</p>
        <p>Key components:</p>
        <ul>
          <li>Functions: Wave calculations and spectrum generation</li>
          <li>Connectors: Data exchange interfaces for wave and structure interactions</li>
          <li>TestDevelopment: Model for testing wave-structure interactions</li>
        </ul>
      </html>"),
      Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {230, 230, 250}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 90}, {90, -90}}, textString = "Internal", fontName = "Arial")}));
  end Internal;

  package Testing
    model DragSimple
      inner Modelica.Mechanics.MultiBody.World world annotation(
        Placement(transformation(origin = {-64, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Sources.Constant const[3](k = {-100, 0, 0}) annotation(
        Placement(transformation(origin = {166, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Mechanics.MultiBody.Parts.PointMass pointMass(m = 1) annotation(
        Placement(transformation(origin = {74, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(r = {1, 0, 0}) annotation(
        Placement(transformation(origin = {48, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {112, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Blocks.Sources.Constant const2[3](k = {100, 0, 0}) annotation(
        Placement(transformation(origin = {-30, 28}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {12, 28}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(useAxisFlange = false) annotation(
        Placement(transformation(origin = {18, 0}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(const.y, force.force) annotation(
        Line(points = {{155, 0}, {124, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(prismatic.frame_b, fixedTranslation.frame_a) annotation(
        Line(points = {{28, 0}, {38, 0}}, color = {95, 95, 95}));
      connect(fixedTranslation.frame_b, pointMass.frame_a) annotation(
        Line(points = {{58, 0}, {74, 0}}, color = {95, 95, 95}));
      connect(force.frame_b, pointMass.frame_a) annotation(
        Line(points = {{102, 0}, {74, 0}}, color = {95, 95, 95}));
      connect(const2.y, force1.force) annotation(
        Line(points = {{-19, 28}, {-1, 28}}, color = {0, 0, 127}, thickness = 0.5));
      connect(force1.frame_b, prismatic.frame_b) annotation(
        Line(points = {{22, 28}, {28, 28}, {28, 0}}, color = {95, 95, 95}));
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-54, 0}, {8, 0}}, color = {95, 95, 95}));
      annotation(
        Diagram(coordinateSystem(extent = {{-80, 40}, {180, -20}})));
    end DragSimple;

    model DragSystem
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity) annotation(
        Placement(transformation(origin = {-82, -82}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.Fixed fixed annotation(
        Placement(transformation(origin = {-2, 74}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 1, 0}) annotation(
        Placement(transformation(origin = {-2, 44}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Mechanics.MultiBody.Parts.PointMass pointMass(m = 10) annotation(
        Placement(transformation(origin = {-2, 8}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Blocks.Sources.Constant const1[3](k = {0, -100, 0}) annotation(
        Placement(transformation(origin = {64, 34}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {30, 8}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {-2, -22}, extent = {{-10, -10}, {10, 10}}, rotation = 90)));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {28, 34}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      DragForce dragForce annotation(
        Placement(transformation(origin = {26, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
    equation
      connect(prismatic.frame_a, fixed.frame_b) annotation(
        Line(points = {{-2, 54}, {-2, 64}}, color = {95, 95, 95}));
      connect(prismatic.frame_b, pointMass.frame_a) annotation(
        Line(points = {{-2, 34}, {-2, 8}}, color = {95, 95, 95}));
      connect(force.frame_b, pointMass.frame_a) annotation(
        Line(points = {{-2, -12}, {-2, 8}}, color = {95, 95, 95}));
      connect(const1.y, force1.force) annotation(
        Line(points = {{53, 34}, {40, 34}}, color = {0, 0, 127}));
      connect(force1.frame_b, prismatic.frame_b) annotation(
        Line(points = {{18, 34}, {-2, 34}}, color = {95, 95, 95}));
      connect(absoluteVelocity.frame_a, pointMass.frame_a) annotation(
        Line(points = {{20, 8}, {-2, 8}}, color = {95, 95, 95}));
      connect(dragForce.y, force.force) annotation(
        Line(points = {{16, -40}, {-1.8, -40}, {-1.8, -33.8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteVelocity.v, dragForce.u) annotation(
        Line(points = {{42, 8}, {44, 8}, {44, -40}, {37, -40}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Diagram);
    end DragSystem;

    block DragForce
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Input Signals (velocity vector)" annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 2}, extent = {{-10, -10}, {10, 10}})));
      parameter Real rho_w = 1.25 "Density of sea water [kg/m^3]";
      parameter Real Cd = 1 "Normal drag coefficient";
      parameter Real A = 1 "Cross-sectional Area of object [m^2]";
      Real Fd[3];
    equation
      Fd = -0.5*rho_w*Cd*A*(u.*abs(u));
      y = Fd;
    end DragForce;

    block DragForce3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Input Signals (velocity vector)" annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (3D drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      parameter Real rho = 1.25 "Density of fluid [kg/m^3]";
      parameter Real A = 1 "Reference area [m^2]";
      parameter Real Cdx = 1 "Drag coefficient for x-axis";
      parameter Real Cdy = 1 "Drag coefficient for y-axis";
      parameter Real Cdz = 1 "Drag coefficient for z-axis";
      parameter Real Cd[3, 3] = diagonal({Cdx, Cdy, Cdz});
      Real c "Combined constant term";
      Real Fd[3] "3D drag force vector";
    equation
      c = 0.5*rho*A;
      Fd = -c*Cd*(u.*abs(u));
      y = Fd;
    end DragForce3D;

    block PTO3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] annotation(
        Placement(transformation(origin = {-106, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-98, 50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput s[3] annotation(
        Placement(transformation(origin = {-106, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-98, -50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (3D drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      parameter Real Kpx = 0.1 "Proportional gain for x-axis";
      parameter Real Kpy = 0.1 "Proportional gain for y-axis";
      parameter Real Kpz = 0.1 "Proportional gain for z-axis";
      parameter Real Kp[3, 3] = diagonal({Kpx, Kpy, Kpz});
      parameter Real Kix = 0.1 "Integral gain for x-axis";
      parameter Real Kiy = 0.1 "Integral gain for y-axis";
      parameter Real Kiz = 0.1 "Integral gain for z-axis";
      parameter Real Ki[3, 3] = diagonal({Kix, Kiy, Kiz});
      Real Fp[3] "PTO";
    equation
      Fp = Kp*u + Ki*s;
      y = -Fp;
    end PTO3D;

    block HydrostaticForce3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 2}, extent = {{-10, -10}, {10, 10}})));
      parameter Real G1 = 0 "hydrostatic restoring coefficients for x-axis";
      parameter Real G2 = 0 "hydrostatic restoring coefficients for y-axis";
      parameter Real G3 = 1 "hydrostatic restoring coefficients for z-axis";
      parameter Real G[3, 3] = diagonal({G1, G2, G3});
    equation
      y = -G*u;
    end HydrostaticForce3D;

    model HydrodynamicBlock3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition absolutePosition annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {-50, 30}, extent = {{-10, -10}, {10, 10}})));
      DragForce3D dragForce3D(Cdx = 0.01, Cdy = 0.01, Cdz = 0.01, rho = 10) annotation(
        Placement(transformation(origin = {-8, 30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {36, 30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {36, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force2 annotation(
        Placement(transformation(origin = {36, -30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      PTO3D pto3d annotation(
        Placement(transformation(origin = {-8, -30}, extent = {{-10, -10}, {10, 10}})));
      HydrostaticForce3D hydrostaticForce3D annotation(
        Placement(transformation(origin = {-8, 0}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(absoluteVelocity.v, dragForce3D.u) annotation(
        Line(points = {{-39, 30}, {-19, 30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(dragForce3D.y, force.force) annotation(
        Line(points = {{2.8, 30}, {24.8, 30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(frame_a, absolutePosition.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
      connect(frame_a, absoluteVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, 30}}));
      connect(force1.frame_b, frame_b) annotation(
        Line(points = {{46, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(force.frame_b, frame_b) annotation(
        Line(points = {{46, 30}, {80, 30}, {80, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(force2.frame_b, frame_b) annotation(
        Line(points = {{46, -30}, {80, -30}, {80, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(pto3d.y, force2.force) annotation(
        Line(points = {{2, -30}, {24, -30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce3D.y, force1.force) annotation(
        Line(points = {{2, 0}, {24, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, hydrostaticForce3D.u) annotation(
        Line(points = {{-38, 0}, {-18, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteVelocity.v, pto3d.u) annotation(
        Line(points = {{-38, 30}, {-30, 30}, {-30, -24}, {-18, -24}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, pto3d.s) annotation(
        Line(points = {{-38, 0}, {-34, 0}, {-34, -34}, {-18, -34}}, color = {0, 0, 127}, thickness = 0.5));
    end HydrodynamicBlock3D;

    model HydrodynamicBlock6DUPD
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition absolutePosition annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {-50, 40}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      HydrostaticForce6D hydrostaticForce6D(enableHydrostaticForce = true) annotation(
        Placement(transformation(origin = {18, -38}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque2 annotation(
        Placement(transformation(origin = {60, -40}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocity absoluteAngularVelocity annotation(
        Placement(transformation(origin = {-50, -32}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles absoluteAngles annotation(
        Placement(transformation(origin = {-50, -60}, extent = {{-10, -10}, {10, 10}})));
      RadiationF radiationF(enableRadiationForce = true) annotation(
        Placement(transformation(origin = {18, 68}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {56, 68}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(frame_a, absolutePosition.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
      connect(absolutePosition.r, hydrostaticForce6D.u) annotation(
        Line(points = {{-38, 0}, {-32, 0}, {-32, -33}, {8, -33}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.y, forceAndTorque2.force) annotation(
        Line(points = {{28, -32}, {48, -32}, {48, -34}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.y1, forceAndTorque2.torque) annotation(
        Line(points = {{28, -42}, {48, -42}, {48, -46}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceAndTorque2.frame_b, frame_b) annotation(
        Line(points = {{70, -40}, {78, -40}, {78, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(frame_a, absoluteVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, 40}}));
      connect(frame_a, absoluteAngularVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, -32}}));
      connect(absoluteAngularVelocity.w, hydrostaticForce6D.theta) annotation(
        Line(points = {{-38, -32}, {-32, -32}, {-32, -42}, {8, -42}}, color = {0, 0, 127}, thickness = 0.5));
      connect(frame_a, absoluteAngles.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, -60}}));
      connect(absoluteVelocity.v, radiationF.v) annotation(
        Line(points = {{-38, 40}, {-38, 72}, {6, 72}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, radiationF.z) annotation(
        Line(points = {{-38, 0}, {-10, 0}, {-10, 64}, {6, 64}}, color = {0, 0, 127}, thickness = 0.5));
      connect(radiationF.y, force.force) annotation(
        Line(points = {{30, 68}, {44, 68}}, color = {0, 0, 127}, thickness = 0.5));
      connect(force.frame_b, frame_b) annotation(
        Line(points = {{66, 68}, {78, 68}, {78, 0}, {102, 0}}, color = {95, 95, 95}));
    end HydrodynamicBlock6DUPD;

    block HydrostaticForce6DUPD
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Linear displacement" annotation(
        Placement(transformation(origin = {-106, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, 50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput theta[3] "Angular displacement" annotation(
        Placement(transformation(origin = {-106, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, -50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Translational hydrostatic force" annotation(
        Placement(transformation(origin = {108, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 50}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Interfaces.RealOutput y1[3] "Rotational hydrostatic torque" annotation(
        Placement(transformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, -50}, extent = {{-10, -10}, {10, 10}})));
      parameter Real G1 = 0 "Hydrostatic restoring coefficient for x-axis translation";
      parameter Real G2 = 0 "Hydrostatic restoring coefficient for y-axis translation";
      parameter Real G3 = 1958672 "Hydrostatic restoring coefficient for z-axis translation";
      parameter Real G4 = 0 "Hydrostatic restoring coefficient for x-axis rotation";
      parameter Real G5 = 0 "Hydrostatic restoring coefficient for y-axis rotation";
      parameter Real G6 = 0 "Hydrostatic restoring coefficient for z-axis rotation";
      parameter Real G[6, 6] = diagonal({G1, G2, G3, G4, G5, G6});
      // Add a switch parameter
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force";
      Real F[6] "Hydrostatic force/torque vector";
      Real u_theta[6] "Combined linear and angular displacements";
    equation
// Combine u and theta into a 6x1 matrix
      u_theta[1:3] = u;
      u_theta[4:6] = theta;
      F = -G*u_theta;
// Use the switch to conditionally output the force
      if enableHydrostaticForce then
        y = F[1:3];
        y1 = F[4:6];
      else
        y = zeros(3);
        y1 = zeros(3);
      end if;
    end HydrostaticForce6DUPD;
  end Testing;

  connector Connectored
    Modelica.Blocks.Interfaces.RealInput u[3] "Linear velocity vector [m/s]" annotation(
      Placement(transformation(origin = {-108, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-98, 50}, extent = {{-20, -20}, {20, 20}})));
    Modelica.Blocks.Interfaces.RealInput a[3] "Angular velocity vector [rad/s]" annotation(
      Placement(transformation(origin = {-108, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-102, -52}, extent = {{-20, -20}, {20, 20}})));
    // Output ports
    Modelica.Blocks.Interfaces.RealOutput y[3] "Translational drag force vector [N]" annotation(
      Placement(transformation(origin = {108, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 50}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Blocks.Interfaces.RealOutput y1[3] "Rotational drag torque vector [N*m]" annotation(
      Placement(transformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}})));
  end Connectored;

  model DragForce6D "6-Dimensional Drag Force and Torque Calculation"
    extends Modelica.Blocks.Icons.Block;
    extends Hydrodynamic.Connectors;
    // Fluid and reference parameters
    parameter Real rho = 1.25 "Density of fluid [kg/m^3]";
    parameter Real A = 1 "Reference area [m^2]";
    // Drag coefficients
    parameter Real Cdx = 1 "Translational drag coefficient for x-axis [-]";
    parameter Real Cdy = 1 "Translational drag coefficient for y-axis [-]";
    parameter Real Cdz = 1 "Translational drag coefficient for z-axis [-]";
    parameter Real Crx = 1 "Rotational drag coefficient for x-axis [-]";
    parameter Real Cry = 1 "Rotational drag coefficient for y-axis [-]";
    parameter Real Crz = 1 "Rotational drag coefficient for z-axis [-]";
    parameter Real Cd[6, 6] = diagonal({Cdx, Cdy, Cdz, Crx, Cry, Crz}) "Combined drag coefficient matrix";
    // Control parameter
    parameter Boolean enableDragForce = true "Switch to enable/disable drag force calculation";
    // Internal variables
    Real c "Combined constant term for drag calculation";
    Real Fd[6] "6D drag force/torque vector [N, N*m]";
    Real v[6] "Combined linear and angular velocity vector [m/s, rad/s]";
  equation
// Calculate the combined constant term
    c = 0.5*rho*A;
// Combine linear and angular velocities into a single vector
    v = cat(1, u, a);
// Calculate the 6D drag force/torque vector
    Fd = -c*Cd*v.*abs(v);
// Use the switch to conditionally output the force and torque
    if enableDragForce then
      y = Fd[1:3];
// Translational drag force
      y1 = Fd[4:6];
// Rotational drag torque
    else
      y = zeros(3);
// Zero translational drag force when disabled
      y1 = zeros(3);
// Zero rotational drag torque when disabled
    end if;
    annotation(
      Documentation(info = "<html>
        <p>This block calculates the 6-dimensional drag force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The drag force/torque is calculated using a quadratic drag model, where the force is proportional to the square of the velocity.</p>
        <p>The block can be enabled or disabled using the <code>enableDragForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>a</code>: Angular velocity vector [rad/s]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational drag force vector [N]</li>
          <li><code>y1</code>: Rotational drag torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>rho</code>: Fluid density [kg/m^3]</li>
          <li><code>A</code>: Reference area [m^2]</li>
          <li><code>Cdx</code>, <code>Cdy</code>, <code>Cdz</code>: Translational drag coefficients [-]</li>
          <li><code>Crx</code>, <code>Cry</code>, <code>Crz</code>: Rotational drag coefficients [-]</li>
        </ul>
        <p>The drag coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
      </html>"));
  end DragForce6D;

  package Connector
  
  
    // Sensor readings
  connector absolutePosition_con
    Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]" annotation(
      Placement(transformation(origin = {-120, 84}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 82}, extent = {{-20, -20}, {20, 20}})));
    Modelica.Blocks.Interfaces.RealInput theta_abs[3] "Angular displacement vector [rad]" annotation(
      Placement(transformation(origin = {-120, 36}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 28}, extent = {{-20, -20}, {20, 20}})));
  end absolutePosition_con;  
    
  connector absoluteVelocity_con
    Modelica.Blocks.Interfaces.RealInput v_abs[3] "Absolute linear velocity vector [m/s]" annotation(
      Placement(transformation(origin = {-120, -42}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -22}, extent = {{-20, -20}, {20, 20}})));
    Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Absolute angular velocity vector [rad/s]" annotation(
      Placement(transformation(origin = {-120, -82}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -76}, extent = {{-20, -20}, {20, 20}})));
  end absoluteVelocity_con;  
    
     // Force and torque output
  connector forceTorque_con
    Modelica.Blocks.Interfaces.RealOutput F[6] "Force/Torque vector [N,N*m]" annotation(
      Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}})));
  end forceTorque_con;
  
  connector inputOutput_con
    Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
      Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
    Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Output frame" annotation(
      Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
  end inputOutput_con;
  
  connector input_con
    Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
      Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
  end input_con;
  
  connector sensorOutput_con
  Modelica.Blocks.Interfaces.RealOutput u_abs[3] "Linear displacement vector [m]" annotation(
      Placement(transformation(origin = {110, 92}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 90}, extent = {{-10, -10}, {10, 10}})));
  Modelica.Blocks.Interfaces.RealOutput v_abs[3] "Absolute linear velocity vector [m/s]" annotation(
      Placement(transformation(origin = {108, -34}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, -26}, extent = {{-10, -10}, {10, 10}})));
  Modelica.Blocks.Interfaces.RealOutput theta_abs[3] "Angular displacement vector [rad]" annotation(
        Placement(transformation(origin = {108, 42}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {109, 40}, extent = {{-10, -10}, {10, 10}})));
  Modelica.Blocks.Interfaces.RealOutput omega_abs[3] "Absolute angular velocity vector [rad/s]" annotation(
        Placement(transformation(origin = {110, -94}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, -82}, extent = {{-10, -10}, {10, 10}})));
  end sensorOutput_con;
  
  connector forceTorqueSum_con
   Modelica.Blocks.Interfaces.RealInput Fr[6] "Radiation Force [N]" annotation(
      Placement(transformation(origin = {-120, 84}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 82}, extent = {{-20, -20}, {20, 20}})));
   Modelica.Blocks.Interfaces.RealInput Fhs[6] "Hydrostatic force [N]" annotation(
      Placement(transformation(origin = {-120, 36}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 28}, extent = {{-20, -20}, {20, 20}})));
    Modelica.Blocks.Interfaces.RealInput Fd[6] "Drag force [N]" annotation(
      Placement(transformation(origin = {-120, -42}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -22}, extent = {{-20, -20}, {20, 20}})));
   Modelica.Blocks.Interfaces.RealInput Fpto[6] "PTO force [N]" annotation(
      Placement(transformation(origin = {-120, -82}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -76}, extent = {{-20, -20}, {20, 20}}))); 
  end forceTorqueSum_con;
  
  connector forceandTorque_con
    Modelica.Blocks.Interfaces.RealOutput F[3] "Translational drag force vector [N]" annotation(
      Placement(transformation(origin = {108, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 50}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Blocks.Interfaces.RealOutput T[3] "Rotational drag torque vector [N*m]" annotation(
      Placement(transformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}})));
  end forceandTorque_con;
  
  end Connector;

  model Sensors
   extends Hydrodynamic.Connector.input_con;
   extends Hydrodynamic.Connector.sensorOutput_con;
   // Sensors
    Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition absolutePosition annotation(
      Placement(transformation(origin = {-50, 22}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
      Placement(transformation(origin = {-50, 70}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocity absoluteAngularVelocity annotation(
      Placement(transformation(origin = {-50, -36}, extent = {{-10, -10}, {10, 10}})));
    Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles absoluteAngles annotation(
      Placement(transformation(origin = {-50, -76}, extent = {{-10, -10}, {10, 10}})));
   
  
  equation
connect(frame_a,absolutePosition.frame_a);
  connect(frame_a,absoluteAngles.frame_a);
  connect(frame_a,absoluteVelocity.frame_a);
  connect(frame_a,absoluteAngularVelocity.frame_a);
  
  connect(absolutePosition.r,u_abs);
  connect(absoluteAngles.angles,theta_abs);
  connect(absoluteVelocity.v,v_abs);
  connect(absoluteAngularVelocity.w,omega_abs);
  
  end Sensors;

  model ForceToqueSum
  extends Hydrodynamic.Connector.forceandTorque_con;
  extends Hydrodynamic.Connector.forceTorqueSum_con;
  
  Real f[6];
  equation
  f = Fr + Fpto + Fd + Fhs;
  
  F = f[1:3];
  T = f[4:6];
  

  end ForceToqueSum;
  annotation(
    Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, fillColor = {230, 240, 255}, fillPattern = FillPattern.Solid, lineColor = {0, 0, 255}), // Regular wave representation
    Line(points = {{-90, 40}, {-75, 60}, {-60, 20}, {-45, 50}, {-30, 10}, {-15, 40}, {0, 20}, {15, 50}, {30, 10}, {45, 60}, {60, 20}, {75, 50}, {90, 40}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), // Irregular wave representation
    Line(points = {{-90, -20}, {-75, 0}, {-60, -30}, {-45, -10}, {-30, -40}, {-15, -15}, {0, -35}, {15, -25}, {30, -45}, {45, -10}, {60, -30}, {75, -20}, {90, -40}}, color = {0, 100, 255}, thickness = 2, smooth = Smooth.Bezier), // Circle to represent water body or hydrodynamic system
    Ellipse(extent = {{-50, 50}, {50, -50}}, lineColor = {0, 0, 255}, fillColor = {0, 170, 255}, fillPattern = FillPattern.Solid), // Text for labeling
    Text(extent = {{-100, -70}, {100, -90}}, lineColor = {0, 0, 255}, textString = "Hydrodynamic Package", fontSize = 14)}),
    Documentation(info = "<html>
    <p><strong>Hydrodynamic Package</strong></p>
    
    <p>This package contains models and components for simulating hydrodynamic systems, 
    particularly focused on Wave Energy Converters (WECs). The current implementation 
    includes a single-body WEC model with various force components in 6 degrees of freedom (6D).</p>
    
    <p><strong>Key Components:</strong></p>
    <ul>
      <li><strong>SingleBodyWEC1D:</strong> A 1D single-body Wave Energy Converter model.</li>
      <li><strong>BodyHD6D:</strong> A 6D hydrodynamic body model that incorporates various force components.</li>
      <li><strong>HydrodynamicBlock6D:</strong> Calculates and applies 6D hydrodynamic forces and moments.</li>
      <li><strong>DragForce6D:</strong> Computes 6D drag forces and torques.</li>
      <li><strong>PTO6D:</strong> Models a 6D Power Take-Off system.</li>
      <li><strong>HydrostaticForce6D:</strong> Calculates 6D hydrostatic forces and torques.</li>
      <li><strong>RadiationF:</strong> Computes radiation forces (currently 1D, vertical direction only).</li>
      <li><strong>ExcitationForce:</strong> Provides excitation forces from external data (currently 1D).</li>
    </ul>
    
    <p><strong>Current Capabilities:</strong></p>
    <p>The package allows for modeling of a single-body WEC with the following features:</p>
    <ul>
      <li>6D modeling of drag, PTO, and hydrostatic forces</li>
      <li>1D modeling of radiation forces (vertical direction only)</li>
      <li>External excitation force input</li>
      <li>Rigid body dynamics in 6D</li>
    </ul>
    
    <p><strong>Limitations and Future Work:</strong></p>
    <ul>
      <li>Radiation forces are currently limited to 1D and should be extended to 6D in future versions</li>
      <li>The excitation force model could be expanded to include full 6D capabilities</li>
      <li>Additional WEC configurations (e.g., multi-body systems) could be implemented</li>
    </ul>
    
    <p>This package provides a foundation for hydrodynamic simulations in Modelica, 
    particularly suited for Wave Energy Converter applications. Users can leverage 
    these components to build and simulate various marine energy devices.</p>
  </html>"),
  uses(Modelica(version = "4.0.0")));
end Hydrodynamic;

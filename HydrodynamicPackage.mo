package Hydrodynamic
  extends Modelica.Icons.Package;
  
  package Example
    extends Modelica.Icons.Package;
    model SingleBodyWEC1D "1D Single-Body Wave Energy Converter Model"
      extends Modelica.Icons.Package;
      // World component (no gravity, Z-axis pointing downwards)
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity, n = {0, 0, -1}) "World coordinate system without gravity" annotation(
        Placement(transformation(origin = {-40, -20}, extent = {{-10, -10}, {10, 10}})));
      // Force application component
      // Prismatic joint for vertical motion
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 0, 1}) "Prismatic joint allowing vertical motion" annotation(
        Placement(transformation(origin = {-14, -20}, extent = {{-10, -10}, {10, 10}})));
      // Hydrodynamic body component
      // Wave profile component
      Forces.HydrodynamicBlock6D hydrodynamicBlock6D(I_11 = 0, I_22 = 0, I_33 = 0, I_21 = 0, I_31 = 0, I_32 = 0, enablePTOForce = false, enableDragForce = false, enableRadiationForce = true) annotation(
        Placement(transformation(origin = {12, -20}, extent = {{-10, -10}, {10, 10}})));
      WaveProfile.IrregularWave.PiersonMoskowitzWave piersonMoskowitzWave annotation(
        Placement(transformation(origin = {70, -20}, extent = {{-10, 10}, {10, -10}}, rotation = -180)));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {38, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
    equation
      // Connections between components
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-30, -20}, {-24, -20}}, color = {95, 95, 95}));
      connect(prismatic.frame_b, hydrodynamicBlock6D.frame_a) annotation(
        Line(points = {{-4, -20}, {2, -20}}, color = {95, 95, 95}));
      connect(forceAndTorque.frame_b, hydrodynamicBlock6D.frame_b) annotation(
        Line(points = {{28, -20}, {22, -20}}, color = {95, 95, 95}));
      connect(piersonMoskowitzWave.F, forceAndTorque.force) annotation(
        Line(points = {{60, -14}, {50, -14}}, color = {0, 0, 127}, thickness = 0.5));
      connect(piersonMoskowitzWave.T, forceAndTorque.torque) annotation(
        Line(points = {{60, -24}, {50, -24}, {50, -26}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Icon(graphics = {
            Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, 
                 color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier),
            Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = {0, 0, 0}, fillPattern = FillPattern.Solid)
        }),
        Documentation(info = "<html>
          <p><b>1D Single-Body Wave Energy Converter (WEC) Model</b></p>
          <p>This model represents a simplified 1D single-body wave energy converter system, 
          focusing on the vertical motion of the body in response to wave excitation forces.</p>
          
          <p><b>Model Description</b></p>
          <p>The WEC consists of a hydrodynamic body constrained to move vertically using a prismatic joint. 
          The body is subjected to wave excitation forces generated by Regular (Linear) and Irregular (PM, Bretschneider, JONSWAP) wave profiles.</p>
          
          <p><b>Key Components</b></p>
          <ul>
            <li><code>world</code>: Defines the world coordinate system without gravity</li>
            <li><code>bodyHD6D</code>: Represents the hydrodynamic body of the WEC</li>
            <li><code>prismatic</code>: Allows vertical motion of the body</li>
            <li><code>Regular and Irregular Wave Profiles</code>: Generates regular and irregular wave excitation forces</li>
            <li><code>forceAndTorque</code>: Applies the excitation force to the body</li>
          </ul>
          
          <p><b>Assumptions and Simplifications</b></p>
          <ul>
            <li>The model considers only vertical motion (1D) of the WEC</li>
            <li>Gravity is not included in the world model</li>
            <li>The excitation force is applied as an external input based on the Pierson-Moskowitz or Regular wave profile</li>
          </ul>
          
          <p><b>Notes</b></p>
          <ul>
            <li>This model serves as a basic framework for WEC simulations and can be extended for more complex analyses</li>
            <li>Additional forces like radiation damping or PTO forces can be added to enhance the model's realism</li>
            <li>Ensure that the BodyHD6D component is properly configured for accurate results</li>
            <li>The wave parameters may need to be adjusted to represent specific sea states</li>
          </ul>
        </html>"),
        Diagram(coordinateSystem(extent = {{-80, 0}, {100, -40}})),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05)
    );
    end SingleBodyWEC1D;
    annotation(
      Icon(graphics = {Polygon(points = {{-40, 40}, {40, 0}, {-40, -40}, {-40, 40}}, lineColor = {0, 0, 0}, fillColor = // Red color for the polygon
      {0, 0, 0}, fillPattern = // Red fill
      FillPattern.Solid)}),
      Documentation(info = "<html>
        <p><b>Wave Energy Converter (WEC) Examples</b></p>
        <p>This package contains example models for Wave Energy Converter (WEC) systems. 
        It provides a set of ready-to-use models that demonstrate various aspects of WEC modeling and simulation.</p>
        
        <p><b>Package Contents</b></p>
        <ul>
          <li><b>SingleBodyWEC1D</b>: A 1D model of a single-body wave energy converter. The hydrodynamic data from the Toroidal Float of the US DoE RM-3</li>
        </ul>
        
        <p><b>Usage</b></p>
        <p>The models in this package can be used as starting points for more complex WEC simulations 
        or as educational tools to understand the basic principles of WEC modeling.</p>
        
        <p><b>See Also</b></p>
        <p>For more detailed information on individual models, please refer to their respective documentation.</p>
      </html>"));
  end Example;

  package Forces
    extends Modelica.Icons.Package;

    model HydrostaticForce6D "6-Dimensional Hydrostatic Force and Torque Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // Hydrostatic restoring coefficients
      parameter Real G1 "Hydrostatic restoring coefficient for x-axis translation [N/m]";
      parameter Real G2 "Hydrostatic restoring coefficient for y-axis translation [N/m]";
      parameter Real G3 "Hydrostatic restoring coefficient for z-axis translation [N/m]";
      parameter Real G4 "Hydrostatic restoring coefficient for x-axis rotation [N*m/rad]";
      parameter Real G5 "Hydrostatic restoring coefficient for y-axis rotation [N*m/rad]";
      parameter Real G6 "Hydrostatic restoring coefficient for z-axis rotation [N*m/rad]";
      parameter Real G[6, 6] = diagonal({G1, G2, G3, G4, G5, G6}) "Combined hydrostatic restoring coefficient matrix";
      // Enable/disable force
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation";
      // Internal variables
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real fhs[6] "Hydrostatic force/torque vector [N, N*m]";
    equation
      // Combine linear and angular displacements into a single vector
      u_theta = cat(1, u_abs, theta_abs);
      // Calculate the 6D hydrostatic force/torque vector
      fhs = -G*u_theta;
      // Use the switch to conditionally output the force and torque
      if enableHydrostaticForce then
        F = fhs;
      else
        F = zeros(6);
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional hydrostatic force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The hydrostatic force/torque is calculated using linear restoring coefficients, where the force is proportional to the displacement from the equilibrium position.</p>
        <p>The block can be enabled or disabled using the <code>enableHydrostaticForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear displacement vector [m]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational hydrostatic force vector [N]</li>
          <li><code>y1</code>: Rotational hydrostatic torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>G1</code>, <code>G2</code>, <code>G3</code>: Translational hydrostatic restoring coefficients [N/m]</li>
          <li><code>G4</code>, <code>G5</code>, <code>G6</code>: Rotational hydrostatic restoring coefficients [N*m/rad]</li>
        </ul>
        <p>The hydrostatic restoring coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
        <p>Note: By default, only the z-axis translation (heave) has a non-zero restoring coefficient, which is typical for floating bodies.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HS 6D", fontName = "Arial")}));
    end HydrostaticForce6D;

    model RadiationF "1D Radiation Force Calculation for Hydrodynamic Systems"
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // Control parameter
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
      // State variables
      Real x[2] "State vector for 1D radiation force model";
      Real F_rad "Calculated 1D radiation force [N]";
    initial equation
      x = {0, 0} "Initialize state vector to zero";
    equation
      // 1D Radiation force state-space model
      // Note: Only the third element of the velocity vector (vertical motion) is used
      der(x) = A*x + B[:, 1]*v_abs[3];
      F_rad = scalar(C*x) + D*v_abs[3];
      // Output: 1D radiation force only in the third element (vertical direction), with enable/disable switch
      if enableRadiationForce then
        F = {0, 0, -F_rad, 0, 0, 0};
      else
        F = {0, 0, 0, 0, 0, 0};
      end if;
      annotation(
        Documentation(info = "<html>
        <h4>1D Radiation Force Model for Hydrodynamic Systems</h4>
        <p>This model calculates the radiation force for hydrodynamic systems using a state-space representation, 
        considering only the vertical direction (1D model).</p>
        
        <p>Model Description:</p>
        <p>The radiation force is computed solely for the vertical direction (third element of the vectors) 
        based on the vertical velocity input. This simplification allows for efficient modeling of systems 
        where the primary concern is the vertical motion, such as in wave energy converters or floating structures.</p>
        
        <p>Inputs:</p>
        <ul>
          <li><code>z[3]</code>: Position vector [m] (currently not used in calculations, included for future extensions)</li>
          <li><code>v[3]</code>: Velocity vector [m/s] (only the third element, representing vertical velocity, is used)</li>
        </ul>
        
        <p>Outputs:</p>
        <ul>
          <li><code>y[3]</code>: Radiation force vector [N] (force applied only in the vertical direction, third element)</li>
        </ul>
        
        <p>Key Parameters:</p>
        <ul>
          <li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>: State-space model matrices and vectors for the 1D system</li>
          <li><code>enableRadiationForce</code>: Boolean switch to enable/disable the radiation force calculation</li>
        </ul>
        
        <p>Notes:</p>
        <ul>
          <li>The state-space model parameters (A, B, C, D) should be adjusted based on the specific 1D hydrodynamic system being modeled.</li>
          <li>This model assumes that the radiation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
          <li>The position input (z) is currently not used in the calculations but is included for potential future enhancements or compatibility with other models.</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "1D Rad F", fontName = "Arial")}));
    end RadiationF;

    model DragForce6D "6-Dimensional Drag Force and Torque Calculation"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      // Fluid and reference parameters
      parameter Real rho "Density of fluid [kg/m^3]";
      parameter Real A "Reference area [m^2]";
      // Drag coefficients
      parameter Real Cdx "Translational drag coefficient for x-axis [-]";
      parameter Real Cdy "Translational drag coefficient for y-axis [-]";
      parameter Real Cdz "Translational drag coefficient for z-axis [-]";
      parameter Real Crx "Rotational drag coefficient for x-axis [-]";
      parameter Real Cry "Rotational drag coefficient for y-axis [-]";
      parameter Real Crz "Rotational drag coefficient for z-axis [-]";
      parameter Real Cd[6, 6] = diagonal({Cdx, Cdy, Cdz, Crx, Cry, Crz}) "Combined drag coefficient matrix";
      // Control parameter
      parameter Boolean enableDragForce = true "Switch to enable/disable drag force calculation";
      // Internal variables
      Real c "Combined constant term for drag calculation";
      Real fd[6] "6D drag force/torque vector [N, N*m]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
    equation
      // Calculate the combined constant term
      c = 0.5*rho*A;
      // Combine linear and angular velocities into a single vector
      v_omega = cat(1, v_abs, omega_abs);
      // Calculate the 6D drag force/torque vector
      fd = -c*Cd*v_omega.*abs(v_omega);
      // Use the switch to conditionally output the force and torque
      if enableDragForce then
        F = fd[1:3];
      else
        F = zeros(6);
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block calculates the 6-dimensional drag force and torque for both translational and rotational motion in a fluid medium.</p>
        <p>The drag force/torque is calculated using a quadratic drag model, where the force is proportional to the square of the velocity.</p>
        <p>The block can be enabled or disabled using the <code>enableDragForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>a</code>: Angular velocity vector [rad/s]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational drag force vector [N]</li>
          <li><code>y1</code>: Rotational drag torque vector [N*m]</li>
        </ul>
        <p>Key Parameters:</p>
        <ul>
          <li><code>rho</code>: Fluid density [kg/m^3]</li>
          <li><code>A</code>: Reference area [m^2]</li>
          <li><code>Cdx</code>, <code>Cdy</code>, <code>Cdz</code>: Translational drag coefficients [-]</li>
          <li><code>Crx</code>, <code>Cry</code>, <code>Crz</code>: Rotational drag coefficients [-]</li>
        </ul>
        <p>The drag coefficients are combined into a diagonal matrix to allow for different coefficients in each dimension.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "Drag F 6D", fontName = "Arial")}));
    end DragForce6D;

    block PTO6D "6-Dimensional Power Take-Off (PTO) System"
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
      
      parameter Modelica.Units.SI.AngularFrequency omega_peak  "Peak spectral frequency";
      Modelica.Units.SI.Mass amdep = Modelica.Math.Vectors.interpolate(w, Adep, omega_peak);
      Modelica.Units.SI.TranslationalDampingConstant Bpto = Modelica.Math.Vectors.interpolate(w, Rdamp, omega_peak);
      Modelica.Units.SI.TranslationalSpringConstant Kpto;
      Modelica.Units.SI.Mass Mpto;
      
      //Modelica.Units.SI.Force Fpto;
      //Modelica.Units.SI.Power Ppto;
      //Modelica.Blocks.Math.ContinuousMean Ppto_avg;
      // Proportional gain parameters
      parameter Real Kpx "Proportional gain for x-axis translation [N/(m/s)]";
      parameter Real Kpy "Proportional gain for y-axis translation [N/(m/s)]";
      Real Kpz "Proportional gain for z-axis translation [N/(m/s)]";
      parameter Real Kprx "Proportional gain for x-axis rotation [N*m/(rad/s)]";
      parameter Real Kpry "Proportional gain for y-axis rotation [N*m/(rad/s)]";
      parameter Real Kprz "Proportional gain for z-axis rotation [N*m/(rad/s)]";
      Real Kp[6, 6] "Combined proportional gain matrix";
      // Integral gain parameters
      parameter Real Kix "Integral gain for x-axis translation [N/m]";
      parameter Real Kiy "Integral gain for y-axis translation [N/m]";
      Real Kiz "Integral gain for z-axis translation [N/m]";
      parameter Real Kirx "Integral gain for x-axis rotation [N*m/rad]";
      parameter Real Kiry "Integral gain for y-axis rotation [N*m/rad]";
      parameter Real Kirz "Integral gain for z-axis rotation [N*m/rad]";
      Real Ki[6, 6] "Combined integral gain matrix";
      // Control parameter
      parameter Boolean enablePTOForce = true "Switch to enable/disable PTO force calculation";
      // Internal variable
      Real fpto[6] "Combined PTO force/torque vector [N, N*m]";
      Real u_theta[6] "Combined displacement vector [m, rad]";
      Real v_omega[6] "Combined linear and angular velocity vector [m/s, rad/s]";
      Real bpto;
      parameter String controllerSelect = "reactive" annotation(
        Dialog(group = "Controller type select"));
    equation
      Kiz = Kpto;
      Kp = diagonal({Kpx, Kpy, Kpz, Kprx, Kpry, Kprz});
      Kpz = bpto;
      Ki = diagonal({Kix, Kiy, Kiz, Kirx, Kiry, Kirz});
      u_theta = cat(1, u_abs, theta_abs);
      v_omega = cat(1, v_abs, omega_abs);
      // Calculate the combined PTO force/torque vector
      fpto = Kp*v_omega + Ki*u_theta;
      Mpto = M + amdep;
      // Use the switch to conditionally output the force and torque
      if enablePTOForce then
        F = -fpto;
      else
        F = zeros(6);
      end if;
      if controllerSelect == "passive" then
        Kpto = 0;
        bpto = (Bpto^2 + (omega_peak*(Mpto) - Khs/omega_peak)^2)^(1/2);
      elseif controllerSelect == "reactive" then
        Kpto = (Mpto)*omega_peak - Khs/omega_peak;
        // no khs in here
        bpto = Bpto;
      end if;
      annotation(
        Documentation(info = "<html>
        <p>This block models a 6-dimensional Power Take-Off (PTO) system for both translational and rotational motion.</p>
        <p>The PTO force/torque is calculated using a combination of proportional and integral control based on the input velocities and displacements.</p>
        <p>The block can be enabled or disabled using the <code>enablePTOForce</code> parameter.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>u</code>: Linear velocity vector [m/s]</li>
          <li><code>s</code>: Linear displacement vector [m]</li>
          <li><code>omega</code>: Angular velocity vector [rad/s]</li>
          <li><code>theta</code>: Angular displacement vector [rad]</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>y</code>: Translational PTO force vector [N]</li>
          <li><code>y1</code>: Rotational PTO torque vector [N*m]</li>
        </ul>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "PTO 6D", fontName = "Arial")}));
    end PTO6D;

    model HydrodynamicBlock6D "6-Dimensional Hydrodynamic Forces and Moments Calculation"
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Units.SI;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.inputOutput_con;
      // Parameters for BodyShape
      parameter Position r[3] = {0, 0, 0} "Position vector" annotation(
        Dialog(group = "Body"));
      parameter Position r_CM[3] = {0, 0, 0} "Center of mass position vector" annotation(
        Dialog(group = "Body"));
      parameter Position length = 0.1 "Length of the body" annotation(
        Dialog(group = "Body"));
      parameter Position width = 0.1 "Width of the body" annotation(
        Dialog(group = "Body"));
      parameter Position height = 0.1 "Height of the body" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_11 = 0.001 "Element (1,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_22 = 0.001 "Element (2,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_33 = 0.001 "Element (3,3) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_21 = 0 "Element (2,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_31 = 0 "Element (3,1) of inertia tensor" annotation(
        Dialog(group = "Body"));
      parameter Inertia I_32 = 0 "Element (3,2) of inertia tensor" annotation(
        Dialog(group = "Body"));
      Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape(r = r, r_CM = r_CM, m = m, length = length, width = width, height = height, I_11 = I_11, I_22 = I_22, I_33 = I_33, I_21 = I_21, I_31 = I_31, I_32 = I_32) annotation(
        Placement(transformation(origin = {10, -84}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for HydrostaticForce6D
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force calculation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter TranslationalSpringConstant G1 = 0 "Hydrostatic restoring coefficient for x-axis translation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter TranslationalSpringConstant G2 = 0 "Hydrostatic restoring coefficient for y-axis translation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter RotationalSpringConstant G4 = 0 "Hydrostatic restoring coefficient for x-axis rotation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter RotationalSpringConstant G5 = 0 "Hydrostatic restoring coefficient for y-axis rotation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      parameter RotationalSpringConstant G6 = 0 "Hydrostatic restoring coefficient for z-axis rotation" annotation(
        Dialog(group = "Hydrostatic Stiffness Parameters"));
      // Hydrostatic Force components
      HydrostaticForce6D hydrostaticForce6D(enableHydrostaticForce = enableHydrostaticForce, G1 = G1, G2 = G2, G3 = G3, G4 = G4, G5 = G5, G6 = G6) "Hydrostatic force calculation" annotation(
        Placement(transformation(origin = {16, -20}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for RadiationF
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation" annotation(
        Dialog(group = "Radiation Force Parameters"));
      // HydrodynamicBlock6D components and connections
      RadiationF radiationF(A = A, B = B, C = C, D = D, enableRadiationForce = enableRadiationForce) "1D Radiation Force Calculation" annotation(
        Placement(transformation(origin = {16, 56}, extent = {{-10, -10}, {10, 10}})));
      
      // Parameters for PTO6D
      parameter Boolean enablePTOForce = false "Switch to enable/disable PTO force calculation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter String controllerSelect = "reactive" "Controller type select" annotation(
        Dialog(group = "PTO Parameters"));
      parameter String fileName1 = "C:/Users/Duke/SysModel2024/DragSystem/hydroCoeff_shit.mat" "Path to the hydroCoeff.mat file" annotation(
        Dialog(group = "PTO Parameters"));
      parameter AngularFrequency omega_peak = 0.9423 "Peak spectral frequency" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpx(unit = "N/(m/s)") = 0.0 "Proportional gain for x-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpy(unit = "N/(m/s)") = 0.0 "Proportional gain for y-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kprx(unit = "N·m/(rad/s)") = 0.0 "Proportional gain for x-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kpry(unit = "N·m/(rad/s)") = 0.0 "Proportional gain for y-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter Real Kprz(unit = "N·m/(rad/s)") = 0.0 "Proportional gain for z-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter TranslationalSpringConstant Kix = 0.0 "Integral gain for x-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter TranslationalSpringConstant Kiy = 0.0 "Integral gain for y-axis translation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kirx = 0.0 "Integral gain for x-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kiry = 0.0 "Integral gain for y-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      parameter RotationalSpringConstant Kirz = 0.0 "Integral gain for z-axis rotation" annotation(
        Dialog(group = "PTO Parameters"));
      
      // PTO components
      PTO6D pto6d(fileName = fileName1, omega_peak = omega_peak, Kpx = Kpx, Kpy = Kpy, Kprx = Kprx, Kpry = Kpry, Kprz = Kprz, Kix = Kix, Kiy = Kiy, Kirx = Kirx, Kiry = Kiry, Kirz = Kirz, enablePTOForce = enablePTOForce, controllerSelect = controllerSelect) "Power Take-Off force calculation" annotation(
        Placement(transformation(origin = {16, -46}, extent = {{-10, -10}, {10, 10}})));

      // Parameters for DragForce6D
      parameter Boolean enableDragForce = false "Switch to enable/disable drag force calculation" annotation(
        Dialog(group = "Drag Parameters"));
      parameter MassConcentration rho = 1000 "Density of fluid" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Area A1 = 1 "Reference area" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdx = 100 "Translational drag coefficient for x-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdy = 0.01 "Translational drag coefficient for y-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cdz = 100 "Translational drag coefficient for z-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Crx = 100 "Rotational drag coefficient for x-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Cry = 0.01 "Rotational drag coefficient for y-axis" annotation(
        Dialog(group = "Drag Parameters"));
      parameter Real Crz = 100 "Rotational drag coefficient for z-axis" annotation(
        Dialog(group = "Drag Parameters"));
      
      // Drag force components
      DragForce6D dragForce6D(rho = rho, A = A1, Cdx = Cdx, Cdy = Cdy, Cdz = Cdz, Crx = Crx, Cry = Cry, Crz = Crz, enableDragForce = enableDragForce) "Drag force calculation" annotation(
        Placement(transformation(origin = {16, 24}, extent = {{-10, -10}, {10, 10}})));
      
      // Force and torque application components
      ForceToqueSum forceToqueSum annotation(
        Placement(transformation(origin = {50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque annotation(
        Placement(transformation(origin = {82, 0}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteSensor absoluteSensor(get_r = true, get_v = true, get_a = false, get_z = false, get_angles = true, get_w = true) annotation(
        Placement(transformation(origin = {-61, 1}, extent = {{-11, -11}, {11, 11}})));
    equation
      connect(bodyShape.frame_a, frame_a) annotation(
        Line(points = {{0, -84}, {-102, -84}, {-102, 0}}, color = {95, 95, 95}));
      connect(bodyShape.frame_b, frame_b) annotation(
        Line(points = {{20, -84}, {102, -84}, {102, 0}}, color = {95, 95, 95}));
      connect(forceAndTorque.frame_b, bodyShape.frame_b) annotation(
        Line(points = {{92, 0}, {92, -84}, {20, -84}}, color = {95, 95, 95}));
      connect(forceToqueSum.F, forceAndTorque.force) annotation(
        Line(points = {{61, 5}, {64, 5}, {64, 6}, {70, 6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceToqueSum.T, forceAndTorque.torque) annotation(
        Line(points = {{61, -5}, {70, -5}, {70, -6}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, radiationF.v_abs) annotation(
        Line(points = {{-68, -11}, {-72, -11}, {-72, 54}, {4, 54}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, radiationF.theta_abs) annotation(
        Line(points = {{-59, -11}, {-72, -11}, {-72, 59}, {4, 59}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, radiationF.omega_abs) annotation(
        Line(points = {{-54, -11}, {-72, -11}, {-72, 48}, {4, 48}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, dragForce6D.omega_abs) annotation(
        Line(points = {{-54, -11}, {-72, -11}, {-72, 16}, {4, 16}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, radiationF.u_abs) annotation(
        Line(points = {{-72, -11}, {-72, 64}, {4, 64}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.w, pto6d.omega_abs) annotation(
        Line(points = {{-54, -12}, {-72, -12}, {-72, -54}, {4, -54}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, pto6d.u_abs) annotation(
        Line(points = {{-72, -12}, {-72, -38}, {4, -38}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, pto6d.theta_abs) annotation(
        Line(points = {{-58, -12}, {-72, -12}, {-72, -44}, {4, -44}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, pto6d.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, -48}, {4, -48}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.v, dragForce6D.v_abs) annotation(
        Line(points = {{-68, -12}, {-72, -12}, {-72, 22}, {4, 22}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.r, hydrostaticForce6D.u_abs) annotation(
        Line(points = {{-72, -12}, {4, -12}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.angles, hydrostaticForce6D.theta_abs) annotation(
        Line(points = {{-58, -12}, {-4, -12}, {-4, -18}, {4, -18}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteSensor.frame_a, bodyShape.frame_b) annotation(
        Line(points = {{-72, 2}, {-86, 2}, {-86, -68}, {20, -68}, {20, -84}}, color = {95, 95, 95}));
      connect(radiationF.F, forceToqueSum.Fr) annotation(
        Line(points = {{27, 56}, {30, 56}, {30, 8}, {38, 8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(dragForce6D.F, forceToqueSum.Fd) annotation(
        Line(points = {{27, 24}, {30, 24}, {30, -2}, {38, -2}}, color = {0, 0, 127}, thickness = 0.5));
      connect(pto6d.F, forceToqueSum.Fpto) annotation(
        Line(points = {{28, -46}, {30, -46}, {30, -8}, {38, -8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.F, forceToqueSum.Fhs) annotation(
        Line(points = {{28, -20}, {30, -20}, {30, 2}, {38, 2}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Diagram,
        Documentation(info = "<html>
        <p>This model calculates and applies 6-dimensional hydrodynamic forces and moments to a multibody system.</p>
        <p>It incorporates the following hydrodynamic effects:</p>
        <ul>
          <li>Drag forces and torques</li>
          <li>Power Take-Off (PTO) forces and torques</li>
          <li>Hydrostatic forces and torques</li>
          <li>Radiation forces</li>
        </ul>
        <p>The model uses absolute position, velocity, and angular sensors to determine the body's state, 
        calculates the various hydrodynamic forces, and applies them to the body.</p>
        <p>Inputs:</p>
        <ul>
          <li><code>frame_a</code>: Input frame for body state</li>
        </ul>
        <p>Outputs:</p>
        <ul>
          <li><code>frame_b</code>: Output frame with applied hydrodynamic forces and torques</li>
        </ul>
        <p>Note: Some force components (e.g., drag and PTO) are disabled by default and can be enabled by modifying the respective parameters.</p>
      </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "HD Block 6D", fontName = "Arial")}));
    end HydrodynamicBlock6D;

    model RadiationF3D "1D Radiation Force Calculation for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
    
      // State-space model parameters for 3D radiation force
      parameter Real A11[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A12[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A13[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A21[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A22[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A23[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A31[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A32[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      parameter Real A33[2, 2] = [0, 1; -1.01116567551434, -0.936555983964093] "State matrix for 3D model";
      
      parameter Real B11[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B12[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B13[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B21[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B22[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B23[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B31[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B32[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      parameter Real B33[2] = {683236.706073938, -585411.342188539} "Input vector for 3D model";
      
      parameter Real C11[2] = {1, 0} "Output vector for 3D model";
      parameter Real C12[2] = {1, 0} "Output vector for 3D model";
      parameter Real C13[2] = {1, 0} "Output vector for 3D model";
      parameter Real C21[2] = {1, 0} "Output vector for 3D model";
      parameter Real C22[2] = {1, 0} "Output vector for 3D model";
      parameter Real C23[2] = {1, 0} "Output vector for 3D model";
      parameter Real C31[2] = {1, 0} "Output vector for 3D model";
      parameter Real C32[2] = {1, 0} "Output vector for 3D model";
      parameter Real C33[2] = {1, 0} "Output vector for 3D model";
      
      parameter Real D11 = 0 "Feed-through scalar for 3D model";
      parameter Real D12 = 0 "Feed-through scalar for 3D model";
      parameter Real D13 = 0 "Feed-through scalar for 3D model";
      parameter Real D21 = 0 "Feed-through scalar for 3D model";
      parameter Real D22 = 0 "Feed-through scalar for 3D model";
      parameter Real D23 = 0 "Feed-through scalar for 3D model";
      parameter Real D31 = 0 "Feed-through scalar for 3D model";
      parameter Real D32 = 0 "Feed-through scalar for 3D model";
      parameter Real D33 = 0 "Feed-through scalar for 3D model";
    
      parameter Real A[3, 3, 2,2] = {
        {A11, A12, A13},
        {A21, A22, A23},
        {A31, A32, A33}
      } "State matrix for 3D model";
      parameter Real B[3, 3, 2] = {
        {B11, B12, B13},
        {B21, B22, B23},
        {B31, B32, B33}
      } "Input matrix for 3D model";
      parameter Real C[3, 3, 2] = {
        {C11, C12, C13},
        {C21, C22, C23},
        {C31, C32, C33}
      } "Output matrix for 3D model";
      parameter Real D[3, 3] = {
        {D11, D12, D13},
        {D21, D22, D23},
        {D31, D32, D33}
      } "Feed-through matrix for 3D model";
    
      // Control parameter
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
    
      // State variables
      Real x[18] "State vector for 1D radiation force model";
      Real F_rad[3] "Calculated 1D radiation force [N]";
    
    initial equation
      x = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} "Initialize state vector to zero";
    
    equation
      // 3D Radiation force state-space model
      for i in 1:3 loop
      for j in 1:3 loop
         der(x[2*i-1:2*i]) = A[i, :, :] * x[2*i-1:2*i] + B[i, :, :] * v_abs;
        F_rad[i] = C[i, :, :] * x[2*i-1:2*i] + D[i, :] * v_abs;
      end for;
    end for;
    
      // Output: 3D radiation force
      if enableRadiationForce then
        F = {F_rad[1], F_rad[2], F_rad[3], 0, 0, 0};
      else
        F = {0, 0, 0, 0, 0, 0};
      end if;
    
      annotation(
        Documentation(info = "<html>
            <h4>3D Radiation Force Model for Hydrodynamic Systems</h4>
            <p>This model calculates the radiation force for hydrodynamic systems using a state-space representation, 
            considering only the vertical directions (3D model).</p>
            
            <p>Model Description:</p>
            <p>The radiation force is computed solely for the vertical direction (third element of the vectors) 
            based on the vertical velocity input. This simplification allows for efficient modeling of systems 
            where the primary concern is the vertical motion, such as in wave energy converters or floating structures.</p>
            
            <p>Inputs:</p>
            <ul>
              <li><code>z[3]</code>: Position vector [m] (currently not used in calculations, included for future extensions)</li>
              <li><code>v[3]</code>: Velocity vector [m/s] (only the third element, representing vertical velocity, is used)</li>
            </ul>
            
            <p>Outputs:</p>
            <ul>
              <li><code>y[3]</code>: Radiation force vector [N] (force applied only in the vertical direction, third element)</li>
            </ul>
            
            <p>Key Parameters:</p>
            <ul>
              <li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>: State-space model matrices and vectors for the 1D system</li>
              <li><code>enableRadiationForce</code>: Boolean switch to enable/disable the radiation force calculation</li>
            </ul>
            
            <p>Notes:</p>
            <ul>
              <li>The state-space model parameters (A, B, C, D) should be adjusted based on the specific 1D hydrodynamic system being modeled.</li>
              <li>This model assumes that the radiation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
              <li>The position input (z) is currently not used in the calculations but is included for potential future enhancements or compatibility with other models.</li>
            </ul>
          </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "6D Rad F", fontName = "Arial")}));
    end RadiationF3D;

    model RadiationF2D "1D Radiation Force Calculation for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.absolutePosition_con;
      extends Hydrodynamic.Connector.absoluteVelocity_con;
      extends Hydrodynamic.Connector.forceTorque_con;
    
     
    
      // Control parameter
      parameter Boolean enableRadiationForce = true "Switch to enable/disable 1D radiation force calculation";
    
      // State variables
      Real x[18] "State vector for 1D radiation force model";
      Real F_rad[3] "Calculated 1D radiation force [N]";
    
    initial equation
      x = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} "Initialize state vector to zero";
    
    equation
      // 3D Radiation force state-space model
      for i in 1:3 loop
      for j in 1:3 loop
         der(x[2*i-1:2*i]) = A[i, :, :] * x[2*i-1:2*i] + B[i, :, :] * v_abs;
        F_rad[i] = C[i, :, :] * x[2*i-1:2*i] + D[i, :] * v_abs;
      end for;
    end for;
    
      // Output: 3D radiation force
      if enableRadiationForce then
        F = {F_rad[1], F_rad[2], F_rad[3], 0, 0, 0};
      else
        F = {0, 0, 0, 0, 0, 0};
      end if;
    
      annotation(
        Documentation(info = "<html>
            <h4>3D Radiation Force Model for Hydrodynamic Systems</h4>
            <p>This model calculates the radiation force for hydrodynamic systems using a state-space representation, 
            considering only the vertical directions (3D model).</p>
            
            <p>Model Description:</p>
            <p>The radiation force is computed solely for the vertical direction (third element of the vectors) 
            based on the vertical velocity input. This simplification allows for efficient modeling of systems 
            where the primary concern is the vertical motion, such as in wave energy converters or floating structures.</p>
            
            <p>Inputs:</p>
            <ul>
              <li><code>z[3]</code>: Position vector [m] (currently not used in calculations, included for future extensions)</li>
              <li><code>v[3]</code>: Velocity vector [m/s] (only the third element, representing vertical velocity, is used)</li>
            </ul>
            
            <p>Outputs:</p>
            <ul>
              <li><code>y[3]</code>: Radiation force vector [N] (force applied only in the vertical direction, third element)</li>
            </ul>
            
            <p>Key Parameters:</p>
            <ul>
              <li><code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>: State-space model matrices and vectors for the 1D system</li>
              <li><code>enableRadiationForce</code>: Boolean switch to enable/disable the radiation force calculation</li>
            </ul>
            
            <p>Notes:</p>
            <ul>
              <li>The state-space model parameters (A, B, C, D) should be adjusted based on the specific 1D hydrodynamic system being modeled.</li>
              <li>This model assumes that the radiation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
              <li>The position input (z) is currently not used in the calculations but is included for potential future enhancements or compatibility with other models.</li>
            </ul>
          </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "6D Rad F", fontName = "Arial")}));
    end RadiationF2D;
    annotation(
      Documentation(info = "<html>
      <h4>Forces Package for Hydrodynamic Systems</h4>
      <p>This package contains various force models used in hydrodynamic systems simulations, particularly for marine and offshore applications.</p>
      <p>Included models:</p>
      <ul>
        <li><b>HydrostaticForce6D:</b> Calculates 6-dimensional hydrostatic force and torque, including both translational and rotational components.</li>
        <li><b>RadiationF1D:</b> Calculates 1-dimensional radiation force using a state-space representation for hydrodynamic systems.</li>
        <li><b>DragForce6D:</b> Computes 6-dimensional drag force and torque, taking into account both translational and rotational drag.</li>
        <li><b>PTO6D:</b> Models a 6-dimensional Power Take-Off (PTO) system using reactive and passive control for both translational and rotational motion.</li>
        <li><b>HydrodynamicBlock6D:</b> Calculates and applies 6-dimensional hydrodynamic forces and moments to a multibody system.</li>
      </ul>
      <p>Each model is thoroughly documented and includes customizable parameters to adapt to various scenarios and environmental conditions.</p>
    </html>"),
      Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics = {
          Polygon(origin = {23.3333, 0.0}, fillColor = {0, 0, 0}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, points = {{-23.333, 30.0}, {46.667, 0.0}, {-23.333, -30.0}}),
          Rectangle(fillColor = {0, 0, 0}, pattern = LinePattern.None, fillPattern = FillPattern.Solid, extent = {{-70, -4.5}, {0, 4.5}})
      })
  );
  end Forces;

  package WaveProfile
    extends Modelica.Icons.Package;

    package RegularWave
      /* Package for regular wave elevation profile and excitation force calculations */
      extends Modelica.Icons.Package;

      model LinearWave "Implementation of linear Airy wave model with excitation force calculation"
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        // Output connector for excitation force
        Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
          Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})),
          Documentation(info = "<html>
            <p>Output connector for the calculated excitation force. Only the vertical component (3rd element) is non-zero.</p>
          </html>"));
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Environmental constants
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega = 0.9423 "Wave frequency [rad/s]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Real Trmp = 50 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Wave Parameters"));
        // Derived parameters
        parameter Modelica.Units.SI.Length zeta = Hs/2 "Wave amplitude [m]";
        parameter Real Tp = 2*pi/omega "Wave period [s]";
        parameter Real k = 2*pi/(1.56*(Tp^2)) "Wave number [1/m]";
        // Variables
        Real ExcCoeffRe "Real component of excitation coefficient";
        Real ExcCoeffIm "Imaginary component of excitation coefficient";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
        // Interpolate excitation coefficients (Re & Im) for the given wave frequency
        ExcCoeffRe = Modelica.Math.Vectors.interpolate(w, F_excRe, omega);
        ExcCoeffIm = Modelica.Math.Vectors.interpolate(w, F_excIm, omega);
        // Define wave elevation profile (SSE)
        SSE = zeta*cos(omega*time);
        // Calculate and apply ramping to the excitation force
        if time < Trmp then
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
        else
          wconn.F_exc = ((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
        end if;
        // Assign excitation force to output (vertical component only)
        y = {0, 0, wconn.F_exc};
        annotation(
          Documentation(info = "<html>
            <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
          </html>"),
          Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = "Linear Wave", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end LinearWave;
      annotation(
        Documentation(info = "<html>
          <p>This package contains models for generating regular wave profiles and calculating associated excitation forces.</p>
          <p>The package currently includes:</p>
          <ul>
            <li>LinearWave: A model implementing the linear Airy wave theory</li>
          </ul>
        </html>"),
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-90, -70}, {90, -90}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "Regular Wave")}));
    end RegularWave;

    package IrregularWave
      /* Package for irregular wave elevation profile and excitation force calculations */
      extends Modelica.Icons.Package;

      model PiersonMoskowitzWave "Implementation of Pierson-Moskowitz (PM) wave spectrum for irregular wave generation"
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        extends Hydrodynamic.Connector.forceandTorque_con;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 100 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_PM(Hs, omega) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
        // Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
        // Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
        // Calculate and apply ramping to the excitation force
        if time < Trmp then
          // Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
          // Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
        // Assign excitation force to output (vertical component only)
        F = {0, 0, wconn.F_exc};
        T = {0, 0, 0};
        annotation(
          Documentation(info = "<html>
            <h4>Pierson-Moskowitz Wave Spectrum Model</h4>
            <p>This model implements the Pierson-Moskowitz (PM) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the PM formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Pierson Moskowitz ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end PiersonMoskowitzWave;

      model BretschneiderWave "Implementation of Bretschneider wave spectrum for irregular wave generation"
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        extends Hydrodynamic.Connector.forceandTorque_con;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_BRT(Hs, omega, omega_peak) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
        // Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
        // Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
        // Calculate and apply ramping to the excitation force
        if time < Trmp then
          // Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
          // Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
        // Assign excitation force to output (vertical component only)
        F = {0, 0, wconn.F_exc};
        T = {0, 0, 0};
        annotation(
          Documentation(info = "<html>
            <p><b>Bretschneider Wave Spectrum Model</b></p>
            <p>This model implements the Bretschneider wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p><b>Key features:</b></p>
            <ul>
              <li>Generates a wave spectrum based on the Bretschneider formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <p><b>Usage Notes:</b></p>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Bretschneider ", fontName = "Arial")}, coordinateSystem(initialScale = 0.1)),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end BretschneiderWave;

      model JonswapWave "Implementation of JONSWAP wave spectrum for irregular wave generation"
        extends Hydrodynamic.readHydroParam;
        extends Modelica.Blocks.Icons.Block;
        import Modelica.Math.Vectors;
        extends Hydrodynamic.Connector.forceandTorque_con;
        // Internal connector for wave properties
        Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
        // Output connector for excitation force
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
        // Wave and environmental parameters
        parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
          Dialog(group = "Environmental Parameters"));
        parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
          Dialog(group = "Wave Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_min = 0.03141 "Lowest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_max = 3.141 "Highest frequency component [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Modelica.Units.SI.AngularFrequency omega_peak = 0.9423 "Peak spectral frequency [rad/s]" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_min = 0.07 "Lower spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Real spectralWidth_max = 0.09 "Upper spectral bound for JONSWAP" annotation(
          Dialog(group = "Spectrum Parameters"));
        parameter Integer n_omega = 100 "Number of frequency components" annotation(
          Dialog(group = "Discretization"));
        parameter Integer localSeed = 614657 "Local random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed = 30020 "Global random seed for frequency selection" annotation(
          Dialog(group = "Random Generation"));
        parameter Real rnd_shft[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed, globalSeed, n_omega) "Random shifts for frequency selection";
        parameter Integer localSeed1 = 614757 "Local random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Integer globalSeed1 = 40020 "Global random seed for phase shifts" annotation(
          Dialog(group = "Random Generation"));
        parameter Real epsilon[n_omega] = Hydrodynamic.Internal.Functions.randomNumberGen(localSeed1, globalSeed1, n_omega) "Wave components phase shift";
        parameter Real Trmp = 200 "Interval for ramping up of waves during start phase [s]" annotation(
          Dialog(group = "Simulation Parameters"));
        // Derived parameters
        parameter Real omega[n_omega] = Hydrodynamic.Internal.Functions.frequencySelector(omega_min, omega_max, rnd_shft) "Selected frequency components [rad/s]";
        parameter Real S[n_omega] = Hydrodynamic.Internal.Functions.spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max) "Spectral values for frequency components [m^2-s/rad]";
        parameter Modelica.Units.SI.Length zeta[n_omega] = sqrt(2*S*omega_min) "Wave amplitude components [m]";
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period components [s]";
        parameter Real k[n_omega] = Hydrodynamic.Internal.Functions.waveNumber(d, omega) "Wave number components [1/m]";
        // Variables
        Real ExcCoeffRe[n_omega] "Real component of excitation coefficient for frequency components";
        Real ExcCoeffIm[n_omega] "Imaginary component of excitation coefficient for frequency components";
        Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
      equation
        // Interpolate excitation coefficients (Re & Im) for each frequency component
        for i in 1:n_omega loop
          ExcCoeffRe[i] = Modelica.Math.Vectors.interpolate(w, F_excRe, omega[i])*rho*g;
          ExcCoeffIm[i] = Modelica.Math.Vectors.interpolate(w, F_excIm, omega[i])*rho*g;
        end for;
        // Calculate sea surface elevation (SSE) as the sum of all wave components
        SSE = sum(zeta.*cos(omega*time - 2*pi*epsilon));
        // Calculate and apply ramping to the excitation force
        if time < Trmp then
          // Ramp up the excitation force during the initial phase
          wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        else
          // Apply full excitation force after the ramping period
          wconn.F_exc = sum((ExcCoeffRe.*zeta.*cos(omega*time - 2*pi*epsilon)) - (ExcCoeffIm.*zeta.*sin(omega*time - 2*pi*epsilon)));
        end if;
        // Assign excitation force to output (vertical component only)
        F = {0, 0, wconn.F_exc};
        T = {0, 0, 0};
        annotation(
          Documentation(info = "<html>
            <h4>JONSWAP Wave Spectrum Model</h4>
            <p>This model implements the JONSWAP (Joint North Sea Wave Project) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the JONSWAP formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
              <li>JONSWAP spectrum is particularly suitable for modeling developing seas and storm conditions</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " JONSWAP ", fontName = "Arial")}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end JonswapWave;

      partial model IrregularWaveParameters
        extends Modelica.Blocks.Icons.Block;
        parameter Real Tp[n_omega] = 2*pi./omega "Wave period";
        annotation(
          Documentation(info = "<html>
            <h4>JONSWAP Wave Spectrum Model</h4>
            <p>This model implements the JONSWAP (Joint North Sea Wave Project) wave spectrum to generate irregular waves and calculate associated excitation forces.</p>
            <p>Key features:</p>
            <ul>
              <li>Generates a wave spectrum based on the JONSWAP formulation</li>
              <li>Discretizes the spectrum into multiple frequency components</li>
              <li>Calculates sea surface elevation (SSE) based on superposition of wave components</li>
              <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
              <li>Applies a ramping function to the excitation force during the initial phase</li>
              <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
            </ul>
            <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
            <h4>Usage Notes:</h4>
            <ul>
              <li>Adjust the spectrum parameters (Hs, omega_peak, etc.) to model different sea states</li>
              <li>The number of frequency components (n_omega) affects the smoothness of the generated waves</li>
              <li>Random seeds can be changed to generate different realizations of the same sea state</li>
              <li>JONSWAP spectrum is particularly suitable for modeling developing seas and storm conditions</li>
            </ul>
          </html>"),
          Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier)}),
          experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
      end IrregularWaveParameters;
      annotation(
        Documentation(info = "<html>
      <p><strong>IrregularWave Package</strong></p>
      <p>This package provides models for generating irregular wave profiles and calculating associated excitation forces using various wave spectra commonly used in ocean engineering and naval architecture.</p>
      <p><em>Included Models:</em></p>
      <ul>
        <p><strong>PiersonMoskowitzWave:</strong> Implements the Pierson-Moskowitz spectrum, suitable for fully developed seas.</p>
        <p><strong>BretschneiderWave:</strong> Implements the Bretschneider spectrum, a two-parameter spectrum also known as the modified Pierson-Moskowitz spectrum.</p>
        <p><strong>JonswapWave:</strong> Implements the JONSWAP (Joint North Sea Wave Project) spectrum, particularly useful for modeling developing seas and storm conditions.</p>
      </ul>
      <p>Each model provides options for customizing sea state parameters and offers both wave elevation profiles and excitation force calculations.</p>
    </html>"),
        Icon(graphics = {Line(points = {{-80, 0}, {-60, 20}, {-40, -20}, {-20, 10}, {0, -10}, {20, 30}, {40, -30}, {60, 15}, {80, -15}}, color = {0, 0, 255}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-90, -70}, {90, -90}}, lineColor = {0, 0, 255}, fillColor = {0, 0, 255}, fillPattern = FillPattern.Solid, textString = "Irregular Wave")}));
    end IrregularWave;

    model waveParameters
      extends Hydrodynamic.readHydroParam;
      extends Modelica.Blocks.Icons.Block;
      extends Hydrodynamic.Connector.forceandTorque_con;
      import Modelica.Math.Vectors;
      // Output connector for excitation force
      Hydrodynamic.Internal.Connectors.WaveOutConn wconn "Internal connector for wave properties";
      // Environmental constants
      constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
      constant Real g = Modelica.Constants.g_n "Acceleration due to gravity [m/s^2]";
      // Wave parameters
      parameter Modelica.Units.SI.Length d = 100 "Water depth [m]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Modelica.Units.SI.Density rho = 1025 "Density of seawater [kg/m^3]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Modelica.Units.SI.Length Hs = 2.5 "Significant Wave Height [m]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Modelica.Units.SI.AngularFrequency omega = 0.9423 "Wave frequency [rad/s]" annotation(
        Dialog(group = "Wave Parameters"));
      parameter Real Trmp = 50 "Interval for ramping up of waves during start phase [s]" annotation(
        Dialog(group = "Wave Parameters"));
      // Derived parameters
      parameter Modelica.Units.SI.Length zeta = Hs/2 "Wave amplitude [m]";
      parameter Real Tp = 2*pi/omega "Wave period [s]";
      parameter Real k = 2*pi/(1.56*(Tp^2)) "Wave number [1/m]";
      // Variables
      Real ExcCoeffRe "Real component of excitation coefficient";
      Real ExcCoeffIm "Imaginary component of excitation coefficient";
      Modelica.Units.SI.Length SSE "Sea surface elevation [m]";
    equation
      // Interpolate excitation coefficients (Re & Im) for the given wave frequency
      ExcCoeffRe = Modelica.Math.Vectors.interpolate(w, F_excRe, omega);
      ExcCoeffIm = Modelica.Math.Vectors.interpolate(w, F_excIm, omega);
      // Define wave elevation profile (SSE)
      SSE = zeta*cos(omega*time);
      // Calculate and apply ramping to the excitation force
      if time < Trmp then
        wconn.F_exc = 0.5*(1 + cos(pi + (pi*time/Trmp)))*((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
      else
        wconn.F_exc = ((ExcCoeffRe*zeta*cos(omega*time)) - (ExcCoeffIm*zeta*sin(omega*time)))*rho*g;
      end if;
      // Assign excitation force to output (vertical component only)
      F = {0, 0, wconn.F_exc};
      T = {0, 0, 0};
      annotation(
        Documentation(info = "<html>
          <p>This model implements the linear Airy wave theory to calculate wave elevation profiles and associated excitation forces.</p>
          <p>Key features:</p>
          <ul>
            <li>Calculates sea surface elevation (SSE) based on wave parameters</li>
            <li>Computes excitation force using interpolated coefficients from hydrodynamic data</li>
            <li>Applies a ramping function to the excitation force during the initial phase</li>
            <li>Outputs the excitation force as a 3D vector (vertical component only)</li>
          </ul>
          <p>The model requires hydrodynamic coefficient data to be provided in a .mat file.</p>
        </html>"),
        Icon(graphics = {Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Text(extent = {{-100, 50}, {100, -150}}, textString = " Linear Wave 2 ", fontName = "Arial")}),
        experiment(StartTime = 0, StopTime = 500, Tolerance = 1e-08, Interval = 0.05));
    end waveParameters;
    annotation(
      Documentation(info = "<html>
      <p><strong>WaveProfile Package</strong></p>
      <p>This package provides comprehensive models for generating wave profiles and calculating associated excitation forces for both regular and irregular waves. It is designed for use in ocean engineering, naval architecture, and offshore structure analysis.</p>
      
      <p><strong>Package Contents:</strong></p>
      <p><strong>1. RegularWave</strong></p>
      <ul>
        <li><strong>LinearWave:</strong> Implements the linear Airy wave theory for regular waves.</li>
      </ul>
      
      <p><strong>2. IrregularWave</strong></p>
      <ul>
        <li><strong>PiersonMoskowitzWave:</strong> Generates irregular waves using the Pierson-Moskowitz spectrum, suitable for fully developed seas.</li>
        <li><strong>BretschneiderWave:</strong> Implements the Bretschneider (modified Pierson-Moskowitz) spectrum for more flexible sea state modeling.</li>
        <li><strong>JonswapWave:</strong> Uses the JONSWAP spectrum, ideal for modeling developing seas and storm conditions.</li>
      </ul>
      
      <p><strong>Key Features:</strong></p>
      <ul>
        <li>Calculation of wave elevation profiles</li>
        <li>Computation of wave-induced excitation forces</li>
        <li>Customizable sea state parameters</li>
        <li>Support for both deterministic (regular) and stochastic (irregular) wave modeling</li>
      </ul>
      
      <p>This package is essential for various marine engineering applications, including offshore structure design, wave energy converter analysis, ship motion studies, and coastal engineering projects.</p>
    </html>"),
      Icon(graphics = {Line(points = {{-90, 20}, {-60, 40}, {-30, 0}, {0, 40}, {30, 0}, {60, 40}, {90, 20}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), // Irregular wave representation
      Line(points = {{-90, -20}, {-75, 0}, {-60, -30}, {-45, -10}, {-30, -40}, {-15, -5}, {0, -35}, {15, -15}, {30, -45}, {45, 0}, {60, -30}, {75, -20}, {90, -40}}, color = {0, 100, 255}, thickness = 2, smooth = Smooth.Bezier)}));
  end WaveProfile;

  package Connector
    extends Modelica.Icons.Package;
  
    connector absolutePosition_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u_abs[3] "Linear displacement vector [m]" annotation(
        Placement(transformation(origin = {-120, 84}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 82}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput theta_abs[3] "Angular displacement vector [rad]" annotation(
        Placement(transformation(origin = {-120, 36}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 28}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>absolutePosition_con Connector</strong></p>
        <p>This connector is used to specify the absolute position and orientation of a component in a 3-dimensional space. It provides input ports for defining linear and angular displacements.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>u_abs:</strong> A 3-dimensional vector representing linear displacement in meters. This vector describes the position of the component in space relative to a reference point.</li>
          <li><strong>theta_abs:</strong> A 3-dimensional vector representing angular displacement in radians. This vector describes the orientation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Utilize this connector in models where precise positioning and orientation of components are required, such as in robotic arms, mechanical linkages, or spatial transformations.</p>
        </html>")
      );
    end absolutePosition_con;
  
    connector absoluteVelocity_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput v_abs[3] "Absolute linear velocity vector [m/s]" annotation(
        Placement(transformation(origin = {-120, -42}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -22}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput omega_abs[3] "Absolute angular velocity vector [rad/s]" annotation(
        Placement(transformation(origin = {-120, -82}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -76}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>absoluteVelocity_con Connector</strong></p>
        <p>This connector is designed to provide input ports for absolute velocity vectors. It includes components for both linear and angular velocities.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>v_abs:</strong> A 3-dimensional vector representing absolute linear velocity in meters per second. This vector describes how quickly the component is moving in each spatial direction.</li>
          <li><strong>omega_abs:</strong> A 3-dimensional vector representing absolute angular velocity in radians per second. This vector describes the rate of rotation of the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Use this connector in systems that require the modeling of velocity effects, such as in dynamic simulations, motion analysis, or control systems for mechanical components.</p>
        </html>")
      );
    end absoluteVelocity_con;
  
    connector forceTorque_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealOutput F[6] "Force/Torque vector [N, N*m]" annotation(
        Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>forceTorque_con Connector</strong></p>
        <p>This connector provides an output port for the force and torque vector. It represents the combined forces and torques applied to or exerted by a component in a 6-dimensional space.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>F:</strong> A 6-dimensional vector representing force and torque in Newtons (N) and Newton-meters (N*m), respectively. This vector includes forces in the 3 spatial directions and torques around the 3 axes.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Employ this connector in models where it is necessary to output or monitor forces and torques, such as in force measurement systems, structural analysis, or mechanical interactions.</p>
        </html>")
      );
    end forceTorque_con;
  
    connector inputOutput_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Output frame" annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>inputOutput_con Connector</strong></p>
        <p>This connector defines frames for input and output connections in mechanical systems. It is used to link components that interact through these frames.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>frame_a:</strong> Input frame used to connect with another component’s output frame. It provides the reference frame for incoming connections.</li>
          <li><strong>frame_b:</strong> Output frame used to connect with another component’s input frame. It provides the reference frame for outgoing connections.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Utilize this connector for interfacing between components in mechanical systems where multiple frames of reference are involved, such as in kinematic chains or multi-body simulations.</p>
        </html>")
      );
    end inputOutput_con;
  
    connector input_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>input_con Connector</strong></p>
        <p>This connector provides an input frame for connecting components in a mechanical system. It serves as the receiving end of a connection for data or signals.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>frame_a:</strong> Input frame used for connection with other components’ output frames. It defines the reference frame for incoming interactions.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Use this connector when you need to receive input from other components or systems, such as in data acquisition systems or signal processing modules.</p>
        </html>")
      );
    end input_con;
  
    connector forceTorqueSum_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput Fr[6] "Radiation Force [N]" annotation(
        Placement(transformation(origin = {-120, 84}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 82}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput Fhs[6] "Hydrostatic force [N]" annotation(
        Placement(transformation(origin = {-120, 36}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-118, 28}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput Fd[6] "Drag force [N]" annotation(
        Placement(transformation(origin = {-120, -42}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -22}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput Fpto[6] "PTO force [N]" annotation(
        Placement(transformation(origin = {-120, -82}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-120, -76}, extent = {{-20, -20}, {20, 20}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>forceTorqueSum_con Connector</strong></p>
        <p>This connector aggregates various components of forces and torques acting on a system. It includes inputs for radiation forces, hydrostatic forces, drag forces, and PTO (Power Take-Off) forces. This comprehensive connector is crucial for summing the effects of different force sources in a mechanical or marine system.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>Fr:</strong> A 6-dimensional vector representing radiation forces in Newtons (N). These forces result from the interaction of a component with radiative waves or fields.</li>
          <li><strong>Fhs:</strong> A 6-dimensional vector representing hydrostatic forces in Newtons (N). These forces arise from the pressure difference in the fluid surrounding the component.</li>
          <li><strong>Fd:</strong> A 6-dimensional vector representing drag forces in Newtons (N). These forces are due to the resistance encountered by the component as it moves through a fluid.</li>
          <li><strong>Fpto:</strong> A 6-dimensional vector representing PTO forces in Newtons (N). These forces are associated with the energy conversion or dissipation mechanisms in wave energy converters or similar systems.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Employ this connector in models where the cumulative effect of multiple force sources needs to be accounted for. It is particularly useful in simulations involving marine structures, energy converters, or complex mechanical systems with multiple interacting forces.</p>
        </html>")
      );
    end forceTorqueSum_con;
  
    connector forceandTorque_con
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealOutput F[3] "Translational drag force vector [N]" annotation(
        Placement(transformation(origin = {108, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {110, 50}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Interfaces.RealOutput T[3] "Rotational drag torque vector [N*m]" annotation(
        Placement(transformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}})));
      annotation(
        Documentation(info = "<html>
        <p><strong>forceandTorque_con Connector</strong></p>
        <p>This connector provides output ports for drag forces and torques experienced by a component. It specifically measures translational drag forces and rotational drag torques, essential for evaluating the effects of drag on a system.</p>
        <p><strong>Ports:</strong></p>
        <ul>
          <li><strong>F:</strong> A 3-dimensional vector representing translational drag forces in Newtons (N). This vector captures the resistance encountered by the component in each spatial direction.</li>
          <li><strong>T:</strong> A 3-dimensional vector representing rotational drag torques in Newton-meters (N*m). This vector captures the resistance to rotation experienced by the component around each axis.</li>
        </ul>
        <p><strong>Usage:</strong></p>
        <p>Use this connector to monitor or analyze the drag effects on components, which is vital for performance assessments in fluid dynamics, aerodynamics, and other drag-related simulations.</p>
        </html>")
      );
    end forceandTorque_con;
  annotation(
      Documentation(info = "<html>
      <h4>Connector Package Overview</h4>
      <p>The Connector package provides a set of connectors designed for integrating various force and motion models within a mechanical or marine system simulation. It includes connectors for handling position, velocity, force, torque, and frame interactions.</p>
      <p><strong>Connectors Included:</strong></p>
      <ul>
        <li><strong>absolutePosition_con:</strong> Handles linear and angular displacement vectors, providing inputs for the absolute position of a component. Taking input from the AbsoluteSensor</li>
        <li><strong>absoluteVelocity_con:</strong> Manages absolute linear and angular velocity vectors, offering inputs for the velocities of a component. Taking input from the AbsoluteSensor</li>
        <li><strong>forceTorque_con:</strong> Outputs a combined force and torque vector, essential for systems where forces and torques need to be monitored or applied.</li>
        <li><strong>inputOutput_con:</strong> Connects two frames, representing the input and output frames for mechanical interactions, such as joints or actuators.</li>
        <li><strong>input_con:</strong> Provides a single input frame for applications where only one frame is needed.</li>
        <li><strong>forceTorqueSum_con:</strong> Aggregates various force types (radiation, hydrostatic, drag, PTO) into a single output.</li>
        <li><strong>forceandTorque_con:</strong> Outputs translational drag forces and rotational drag torques, focused on drag-related effects in the system.</li>
      </ul>
      <p><strong>Applications:</strong></p>
      <ul>
        <li>Integration of position and velocity sensors in mechanical systems.</li>
        <li>Combining and analyzing multiple force sources in marine and mechanical simulations.</li>
        <li>Defining and connecting mechanical frames for accurate modeling of interactions.</li>
      </ul>
      <p>This package is essential for creating detailed and accurate simulations of mechanical and marine systems, allowing for comprehensive analysis and system integration. Separates torque and force outputs so they can be past to the worldforceandtorque block</p>
      </html>"));
  end Connector;

  model ForceToqueSum
    extends Modelica.Blocks.Icons.Block;
    extends Hydrodynamic.Connector.forceandTorque_con;
    extends Hydrodynamic.Connector.forceTorqueSum_con;
    Real f[6];
  equation
    f = Fr + Fpto + Fd + Fhs;
    F = f[1:3];
    T = f[4:6];
  end ForceToqueSum;

  model readHydroParam
    extends Modelica.Units.SI;
    extends Modelica.Icons.Package;
    parameter String fileName = "C:/Users/Duke/SysModel2024/DragSystem/hydroCoeff.mat" "Path to the hydroCoeff.mat file";
    parameter Real A[2, 2] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.A", 2, 2) "State matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Real B[2, 1] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.B", 2, 1) "Input matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Real C[1, 2] = Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.C", 1, 2) "Output matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Real D = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.ss_rad33.D", 1, 1)) "Feed matrix" annotation(
      Dialog(group = "Radiation Force Parameters"));
    parameter Mass m = M + Ainf "Mass of the body" annotation(
      Dialog(group = "Body"));
    parameter TranslationalSpringConstant G3 = Khs "Hydrostatic restoring coefficient for z-axis translation" annotation(
      Dialog(group = "Hydrostatic Stiffness Parameters"));
    parameter Modelica.Units.SI.Mass M = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.m33", 1, 1)) "Total mass of the body (including ballast)";
    parameter Modelica.Units.SI.Mass Ainf = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.Ainf33", 1, 1)) "Added mass at maximum (cut-off) frequency";
    parameter Modelica.Units.SI.TranslationalSpringConstant Khs = scalar(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.Khs33", 1, 1)) "Hydrostatic stiffness";
    parameter Integer wDims[:] = Modelica.Utilities.Streams.readMatrixSize(fileName, "hydroCoeff.w") "Dimensions of the frequency vector";
    parameter Integer wSize = wDims[2] "Size of the frequency vector";
    parameter Real F_excRe[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcRe", 1, wSize)) "Real part of excitation force coefficients";
    parameter Real F_excIm[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.FexcIm", 1, wSize)) "Imaginary part of excitation force coefficients";
    parameter Real w[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.w", 1, wSize)) "Angular frequency vector [rad/s]";
    parameter Real Adep[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.added_mass", wSize, 1)) "Frequency dependent added mass";
    parameter Real Rdamp[:] = vector(Modelica.Utilities.Streams.readRealMatrix(fileName, "hydroCoeff.radiation_damping", wSize, 1)) "Radiation damping";
    
  equation

  annotation(
      Documentation(info = "<html>
      <p><strong>readHydroParam Model</strong></p>
      <p>This model is designed to read and store hydrodynamic parameters from a MATLAB .mat file. These parameters are crucial for accurate modeling of radiation forces and other hydrodynamic effects in marine and offshore engineering applications. This is also used to store parameters and extend to other blocks. </p>
      
      <p><strong>Parameters:</strong></p>
      <ul>
        <li><strong>fileName:</strong> Path to the MATLAB .mat file containing hydrodynamic coefficients and matrices.</li>
        <li><strong>A:</strong> State matrix of the system, read from the .mat file.</li>
        <li><strong>B:</strong> Input matrix for the system, read from the .mat file.</li>
        <li><strong>C:</strong> Output matrix for the system, read from the .mat file.</li>
        <li><strong>D:</strong> Feed matrix for the system, read from the .mat file.</li>
        <li><strong>m:</strong> Total mass of the body, including added mass.</li>
        <li><strong>G3:</strong> Hydrostatic restoring coefficient for z-axis translation.</li>
        <li><strong>M:</strong> Total mass of the body (including ballast).</li>
        <li><strong>Ainf:</strong> Added mass at maximum (cut-off) frequency.</li>
        <li><strong>Khs:</strong> Hydrostatic stiffness.</li>
        <li><strong>wDims:</strong> Dimensions of the frequency vector.</li>
        <li><strong>wSize:</strong> Size of the frequency vector.</li>
        <li><strong>F_excRe:</strong> Real part of excitation force coefficients.</li>
        <li><strong>F_excIm:</strong> Imaginary part of excitation force coefficients.</li>
        <li><strong>w:</strong> Angular frequency vector [rad/s].</li>
      </ul>
      
      <p><strong>Usage:</strong></p>
      <p>This model is essential for integrating empirical data into hydrodynamic simulations, enabling accurate modeling of radiation forces and system responses based on real-world measurements.</p>
      <p><strong>Applications:</strong></p>
      <ul>
        <li>Marine engineering and offshore structure design.</li>
        <li>Dynamic response analysis of marine systems under wave loads.</li>
        <li>Hydrodynamic modeling for wave energy converters and coastal engineering projects.</li>
      </ul>
    </html>"));
  end readHydroParam;

  package Internal
    /* Internal library of core functions and connectors for ocean engineering applications
                           This package contains essential components for wave modeling and structure interactions */
    package Functions
      /* Package defining explicit library functions for wave calculations and random number generation
                                       This package contains a collection of functions essential for ocean engineering simulations,
                                       including wave number calculations, random number generation, and various wave spectrum generators. */
      extends Modelica.Icons.Package;
      function waveNumber "Function to iteratively compute the wave number from frequency components"
        /* Uses the dispersion relationship for water waves to calculate wave numbers
                                                   This function implements an iterative method to solve the implicit dispersion equation */
        input Real d "Water depth [m]";
        input Real omega[:] "Array of wave frequency components [rad/s]";
        output Real k[size(omega, 1)] "Array of wave number components [rad/m]";
      protected
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        parameter Integer n = size(omega, 1) "Number of frequency components";
        Real T[size(omega, 1)] "Array of wave period components [s]";
        Real L0[size(omega, 1)] "Array of deepwater wavelength components [m]";
        Real L1(start = 0, fixed = true) "Temporary variable for wavelength iteration [m]";
        Real L1c(start = 0, fixed = true) "Temporary variable for wavelength iteration comparison [m]";
        Real L[size(omega, 1)] "Array of iterated wavelength components [m]";
      algorithm
        T := 2*pi./omega;
        L0 := g*T.^2/(2*pi);
        for i in 1:size(omega, 1) loop
          L1 := L0[i];
          L1c := 0;
          while abs(L1c - L1) > 0.001 loop
            L1c := L1;
            L[i] := g*T[i]^2/(2*pi)*tanh(2*pi/L1*d);
            L1 := L[i];
          end while;
        end for;
        k := 2*pi./L;
        annotation(
          Documentation(info = "<html>
            <p>Syntax: k = waveNumber(d, omega)</p>
            <p>Description: This function calculates wave numbers for given frequencies and water depth using the dispersion relationship for water waves. It employs an iterative method to solve the implicit dispersion equation.</p>
            <p>Inputs:</p>
            <ul>
              <li><code>d</code>: Water depth [m]</li>
              <li><code>omega</code>: Array of wave frequency components [rad/s]</li>
            </ul>
            <p>Outputs:</p>
            <ul>
              <li><code>k</code>: Array of wave number components [rad/m]</li>
            </ul>
            <p>Algorithm:</p>
            <ol>
              <li>Calculate wave periods from frequencies</li>
              <li>Calculate deepwater wavelengths</li>
              <li>Iterate to solve the dispersion equation for each frequency component</li>
              <li>Convert wavelengths to wave numbers</li>
            </ol>
          </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "k(ω)", textStyle = {TextStyle.Bold}), Line(points = {{-80, -80}, {80, 80}}, color = {0, 0, 255}, thickness = 0.5)}),
          Diagram(graphics = {Text(extent = {{-100, 80}, {100, 40}}, textString = "Wave Number Calculation"), Line(points = {{-80, 0}, {80, 0}}, color = {0, 0, 255}), Line(points = {{0, -80}, {0, 80}}, color = {0, 0, 255}), Text(extent = {{-60, -20}, {60, -60}}, textString = "k = 2π/L")}),
          experiment(StopTime = 1.0, Tolerance = 1e-06));
      end waveNumber;

      function randomNumberGen "Function to generate random numbers using XOR shift algorithm"
        /* Produces a vector of random numbers based on local and global seeds
                                                 This function utilizes the Xorshift64star algorithm for efficient random number generation */
        input Integer ls = 614657 "Local seed for random number generation";
        input Integer gs = 30020 "Global seed for random number generation";
        input Integer n = 100 "Number of random numbers to generate";
        output Real r64[n] "Vector of generated random numbers";
      protected
        Integer state64[2](each start = 0, each fixed = true) "State vector for XOR shift algorithm";
      algorithm
        state64[1] := 0;
        state64[2] := 0;
        for i in 1:n loop
          if i == 1 then
            state64 := Modelica.Math.Random.Generators.Xorshift64star.initialState(ls, gs);
            r64[i] := 0;
          else
            (r64[i], state64) := Modelica.Math.Random.Generators.Xorshift64star.random((state64));
          end if;
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: r64 = randomNumberGen(ls, gs, n)</p>
          <p>Description: This function generates a vector of random numbers using the Xorshift64star algorithm, which is known for its efficiency and good statistical properties.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>ls</code>: Local seed for random number generation (default: 614657)</li>
            <li><code>gs</code>: Global seed for random number generation (default: 30020)</li>
            <li><code>n</code>: Number of random numbers to generate (default: 100)</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>r64</code>: Vector of generated random numbers</li>
          </ul>
          <p>Algorithm: The function uses the Xorshift64star algorithm to generate random numbers based on the provided seeds.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "RNG", textStyle = {TextStyle.Bold})}));
      end randomNumberGen;

      function frequencySelector "Function to randomly select frequency components within a specified range"
        /* Uses a random phase vector to perturb frequencies
                                                 This function ensures a good distribution of frequencies for irregular wave generation */
        input Real omega_min "Minimum frequency [rad/s]";
        input Real omega_max "Maximum frequency [rad/s]";
        input Real epsilon[:] "Random phase vector for frequency perturbation";
        output Real omega[size(epsilon, 1)] "Output vector of selected frequency components [rad/s]";
      protected
        parameter Real ref_omega[size(epsilon, 1)] = omega_min:(omega_max - omega_min)/(size(epsilon, 1) - 1):omega_max "Reference frequency vector [rad/s]";
      algorithm
        omega[1] := omega_min;
        for i in 2:size(epsilon, 1) - 1 loop
          omega[i] := ref_omega[i] + epsilon[i]*omega_min;
        end for;
        omega[size(epsilon, 1)] := omega_max;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: omega = frequencySelector(omega_min, omega_max, epsilon)</p>
          <p>Description: This function selects frequency components within a specified range, using a random phase vector to perturb the frequencies. This ensures a good distribution of frequencies for irregular wave generation.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>omega_min</code>: Minimum frequency [rad/s]</li>
            <li><code>omega_max</code>: Maximum frequency [rad/s]</li>
            <li><code>epsilon</code>: Random phase vector for frequency perturbation</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>omega</code>: Output vector of selected frequency components [rad/s]</li>
          </ul>
          <p>Algorithm: The function creates a reference frequency vector and then perturbs it using the random phase vector, ensuring the first and last frequencies are exactly omega_min and omega_max.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "ω(ε)", textStyle = {TextStyle.Bold})}));
      end frequencySelector;

      function spectrumGenerator_PM "Function to generate Pierson-Moskowitz spectrum"
        /* Calculates spectral values for given frequencies based on significant wave height
                                                 This function implements the Pierson-Moskowitz spectrum, suitable for fully developed seas */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
      algorithm
        for i in 1:size(omega, 1) loop
          spec[i] := 0.0081*g^2/omega[i]^5*exp(-0.0358*(g/(Hs*omega[i]^2))^2);
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_PM(Hs, omega)</p>
          <p>Description: This function generates the Pierson-Moskowitz spectrum, which is suitable for fully developed seas. It calculates spectral values for given frequencies based on the significant wave height.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the Pierson-Moskowitz formula: S(ω) = 0.0081*g^2/ω^5 * exp(-0.0358*(g/(Hs*ω^2))^2)</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "PM", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_PM;

      function spectrumGenerator_BRT "Function to generate Bretschneider spectrum"
        /* Calculates spectral values based on significant wave height and peak frequency
                                                 This function implements the Bretschneider spectrum, a two-parameter spectrum for fetch-limited seas */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
      algorithm
        for i in 1:size(omega, 1) loop
          spec[i] := 1.9635*Hs^2*omega_peak^4/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4));
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_BRT(Hs, omega, omega_peak)</p>
          <p>Description: This function generates the Bretschneider spectrum, which is a two-parameter spectrum suitable for fetch-limited seas. It calculates spectral values based on significant wave height and peak frequency.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
            <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the Bretschneider formula: S(ω) = 1.9635*Hs^2*ω_peak^4/ω^5 * exp(-1.25*((ω_peak/ω)^4))</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "BRT", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_BRT;

      function spectrumGenerator_JONSWAP "Function to generate JONSWAP (Joint North Sea Wave Project) spectrum"
        /* Calculates spectral values based on significant wave height, peak frequency, and spectral width parameters
                                                 This function implements the JONSWAP spectrum, suitable for developing seas with fetch limitations */
        input Real Hs = 1 "Significant wave height [m]";
        input Real omega[:] "Array of frequency components [rad/s]";
        input Real omega_peak = 0.9423 "Peak spectral frequency [rad/s]";
        input Real spectralWidth_min "Minimum spectral width parameter";
        input Real spectralWidth_max "Maximum spectral width parameter";
        output Real spec[size(omega, 1)] "Array of spectral values for input frequencies [m^2s]";
      protected
        constant Real pi = Modelica.Constants.pi "Mathematical constant pi";
        constant Real g = Modelica.Constants.g_n "Gravitational acceleration [m/s^2]";
        constant Real gamma = 3.3 "Peak enhancement factor for JONSWAP spectrum";
        Real sigma "Spectral width parameter";
        Real b "Exponent for peak enhancement factor";
      algorithm
        for i in 1:size(omega, 1) loop
          if omega[i] > omega_peak then
            sigma := spectralWidth_max;
          else
            sigma := spectralWidth_min;
          end if;
          b := exp(-0.5*(((omega[i] - omega_peak)/(sigma*omega_peak))^2));
          spec[i] := 0.0081*g^2/omega[i]^5*exp(-1.25*((omega_peak/omega[i])^4))*gamma^b;
        end for;
        annotation(
          Documentation(info = "<html>
          <p>Syntax: spec = spectrumGenerator_JONSWAP(Hs, omega, omega_peak, spectralWidth_min, spectralWidth_max)</p>
          <p>Description: This function generates the JONSWAP (Joint North Sea Wave Project) spectrum, which is suitable for developing seas with fetch limitations. It calculates spectral values based on significant wave height, peak frequency, and spectral width parameters.</p>
          <p>Inputs:</p>
          <ul>
            <li><code>Hs</code>: Significant wave height [m] (default: 1)</li>
            <li><code>omega</code>: Array of frequency components [rad/s]</li>
            <li><code>omega_peak</code>: Peak spectral frequency [rad/s] (default: 0.9423)</li>
            <li><code>spectralWidth_min</code>: Minimum spectral width parameter</li>
            <li><code>spectralWidth_max</code>: Maximum spectral width parameter</li>
          </ul>
          <p>Outputs:</p>
          <ul>
            <li><code>spec</code>: Array of spectral values for input frequencies [m^2s]</li>
          </ul>
          <p>Algorithm: The function calculates spectral values using the JONSWAP formula, which is an extension of the Pierson-Moskowitz spectrum with additional parameters to account for fetch-limited seas.</p>
        </html>"),
          Icon(graphics = {Rectangle(extent = {{-100, 100}, {100, -100}}, lineColor = {0, 0, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Text(extent = {{-90, 50}, {90, -50}}, textString = "JONSWAP", textStyle = {TextStyle.Bold})}));
      end spectrumGenerator_JONSWAP;
      annotation(
        Documentation(info = "<html>
          <p>This package contains a set of functions essential for ocean engineering simulations:</p>
          <ul>
            <li><b>waveNumber:</b> Calculates wave numbers using the dispersion relationship</li>
            <li><b>randomNumberGen:</b> Generates random numbers using the XOR shift algorithm</li>
            <li><b>frequencySelector:</b> Selects frequency components for irregular wave generation</li>
            <li><b>spectrumGenerator_PM:</b> Generates Pierson-Moskowitz spectrum</li>
            <li><b>spectrumGenerator_BRT:</b> Generates Bretschneider spectrum</li>
            <li><b>spectrumGenerator_JONSWAP:</b> Generates JONSWAP spectrum</li>
          </ul>
          <p>These functions provide the core calculations needed for wave modeling and analysis in ocean engineering applications.</p>
        </html>"),
        Icon(graphics = {Text(extent = {{-90, 90}, {90, 50}}, lineColor = {0, 0, 0}, textString = "f(x)"), Line(points = {{-80, -20}, {-60, 20}, {-40, -40}, {-20, 40}, {0, -20}, {20, 60}, {40, -60}, {60, 20}, {80, -40}}, color = {0, 0, 255}, smooth = Smooth.Bezier), Text(extent = {{-90, -50}, {90, -90}}, lineColor = {0, 0, 0}, textString = "Functions")}));
    end Functions;

    package Connectors
      /* Package defining library connectors for data exchange between components */

      connector WaveOutConn "Output connector for wave data"
        Modelica.Blocks.Interfaces.RealOutput F_exc "Excitation force [N]";
      end WaveOutConn;

      connector WaveInConn "Input connector for wave data"
        Modelica.Blocks.Interfaces.RealInput F_exc "Excitation force [N]";
      end WaveInConn;

      connector DataCollector "Output connector for collecting simulation data"
        Modelica.Blocks.Interfaces.RealOutput F_rad "Radiation force [N]";
        Modelica.Blocks.Interfaces.RealOutput v_z "Vertical velocity [m/s]";
      end DataCollector;
    end Connectors;

    model TestDevelopment "Model to test all wave components and WEC rigid body interactions"
      /* Demonstrates the use of different wave types and their connections to rigid body models */
      parameter String filePath = "C:/Users/Duke/SysModel2024/DragSystem/hydroCoeff.mat" "File path for hydrodynamic coefficients";
      // Wave models
      Hydrodynamic.WaveProfile.RegularWave.LinearWave Reg1(fileName = filePath, Hs = 2.5, Trmp = 50) "Regular linear wave model";
      Hydrodynamic.WaveProfile.IrregularWave.PiersonMoskowitzWave Irr1(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular Pierson-Moskowitz wave model";
      Hydrodynamic.WaveProfile.IrregularWave.BretschneiderWave Irr2(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular Bretschneider wave model";
      Hydrodynamic.WaveProfile.IrregularWave.JonswapWave Irr3(fileName = filePath, Hs = 2.5, n_omega = 100, Trmp = 50) "Irregular JONSWAP wave model";
      // Rigid body models
      Hydrodynamic.Structures.RigidBody Body1(fileName = filePath) "Rigid body for regular wave interaction";
      Hydrodynamic.Structures.RigidBody Body2(fileName = filePath) "Rigid body for Pierson-Moskowitz wave interaction";
      Hydrodynamic.Structures.RigidBody Body3(fileName = filePath) "Rigid body for Bretschneider wave interaction";
      Hydrodynamic.Structures.RigidBody Body4(fileName = filePath) "Rigid body for JONSWAP wave interaction";
    equation
      // Connect wave models to corresponding rigid bodies
      connect(Reg1.wconn.F_exc, Body1.wconn.F_exc) "Connection for regular wave excitation";
      connect(Irr1.wconn.F_exc, Body2.wconn.F_exc) "Connection for Pierson-Moskowitz wave excitation";
      connect(Irr2.wconn.F_exc, Body3.wconn.F_exc) "Connection for Bretschneider wave excitation";
      connect(Irr3.wconn.F_exc, Body4.wconn.F_exc) "Connection for JONSWAP wave excitation";
      annotation(
        experiment(StartTime = 0, StopTime = 200, Tolerance = 1e-06, Interval = 0.1),
        Documentation(info = "<html>
          <p>This model demonstrates the interaction between different wave types and rigid body structures.</p>
          <p>It includes regular and irregular wave models connected to corresponding rigid body models for simulation.</p>
        </html>"));
    end TestDevelopment;
    annotation(
      Documentation(info = "<html>
        <p>This package contains internal functions, connectors, and test models for the Ocean Engineering Toolbox.</p>
        <p>Key components:</p>
        <ul>
          <li>Functions: Wave calculations and spectrum generation</li>
          <li>Connectors: Data exchange interfaces for wave and structure interactions</li>
          <li>TestDevelopment: Model for testing wave-structure interactions</li>
        </ul>
      </html>"),
      Icon(coordinateSystem(preserveAspectRatio = false, extent = {{-100, -100}, {100, 100}}), graphics = {Rectangle(lineColor = {215, 215, 215}, fillColor = {255, 255, 255}, fillPattern = FillPattern.HorizontalCylinder, extent = {{-100, -100}, {100, 100}}, radius = 25), Rectangle(lineColor = {215, 215, 215}, extent = {{-100, -100}, {100, 100}}, radius = 25), Ellipse(extent = {{-80, 80}, {80, -80}}, lineColor = {215, 215, 215}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid), Ellipse(extent = {{-55, 55}, {55, -55}}, lineColor = {255, 255, 255}, fillColor = {255, 255, 255}, fillPattern = FillPattern.Solid), Rectangle(extent = {{-60, 14}, {60, -14}}, lineColor = {215, 215, 215}, fillColor = {215, 215, 215}, fillPattern = FillPattern.Solid, rotation = 45)}));
  end Internal;

  package Archive
    extends Modelica.Icons.Package;

    model DragSimple
      inner Modelica.Mechanics.MultiBody.World world annotation(
        Placement(transformation(origin = {-64, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Sources.Constant const[3](k = {-100, 0, 0}) annotation(
        Placement(transformation(origin = {166, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Mechanics.MultiBody.Parts.PointMass pointMass(m = 1) annotation(
        Placement(transformation(origin = {74, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(r = {1, 0, 0}) annotation(
        Placement(transformation(origin = {48, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {112, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Blocks.Sources.Constant const2[3](k = {100, 0, 0}) annotation(
        Placement(transformation(origin = {-30, 28}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {12, 28}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(useAxisFlange = false) annotation(
        Placement(transformation(origin = {18, 0}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(const.y, force.force) annotation(
        Line(points = {{155, 0}, {124, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(prismatic.frame_b, fixedTranslation.frame_a) annotation(
        Line(points = {{28, 0}, {38, 0}}, color = {95, 95, 95}));
      connect(fixedTranslation.frame_b, pointMass.frame_a) annotation(
        Line(points = {{58, 0}, {74, 0}}, color = {95, 95, 95}));
      connect(force.frame_b, pointMass.frame_a) annotation(
        Line(points = {{102, 0}, {74, 0}}, color = {95, 95, 95}));
      connect(const2.y, force1.force) annotation(
        Line(points = {{-19, 28}, {-1, 28}}, color = {0, 0, 127}, thickness = 0.5));
      connect(force1.frame_b, prismatic.frame_b) annotation(
        Line(points = {{22, 28}, {28, 28}, {28, 0}}, color = {95, 95, 95}));
      connect(world.frame_b, prismatic.frame_a) annotation(
        Line(points = {{-54, 0}, {8, 0}}, color = {95, 95, 95}));
      annotation(
        Diagram(coordinateSystem(extent = {{-80, 40}, {180, -20}})));
    end DragSimple;

    model DragSystem
      inner Modelica.Mechanics.MultiBody.World world(gravityType = Modelica.Mechanics.MultiBody.Types.GravityTypes.NoGravity) annotation(
        Placement(transformation(origin = {-82, -82}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.Fixed fixed annotation(
        Placement(transformation(origin = {-2, 74}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Mechanics.MultiBody.Joints.Prismatic prismatic(n = {0, 1, 0}) annotation(
        Placement(transformation(origin = {-2, 44}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Mechanics.MultiBody.Parts.PointMass pointMass(m = 10) annotation(
        Placement(transformation(origin = {-2, 8}, extent = {{-10, -10}, {10, 10}}, rotation = -90)));
      Modelica.Blocks.Sources.Constant const1[3](k = {0, -100, 0}) annotation(
        Placement(transformation(origin = {64, 34}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {30, 8}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {-2, -22}, extent = {{-10, -10}, {10, 10}}, rotation = 90)));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {28, 34}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
      DragForce dragForce annotation(
        Placement(transformation(origin = {26, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 180)));
    equation
      connect(prismatic.frame_a, fixed.frame_b) annotation(
        Line(points = {{-2, 54}, {-2, 64}}, color = {95, 95, 95}));
      connect(prismatic.frame_b, pointMass.frame_a) annotation(
        Line(points = {{-2, 34}, {-2, 8}}, color = {95, 95, 95}));
      connect(force.frame_b, pointMass.frame_a) annotation(
        Line(points = {{-2, -12}, {-2, 8}}, color = {95, 95, 95}));
      connect(const1.y, force1.force) annotation(
        Line(points = {{53, 34}, {40, 34}}, color = {0, 0, 127}));
      connect(force1.frame_b, prismatic.frame_b) annotation(
        Line(points = {{18, 34}, {-2, 34}}, color = {95, 95, 95}));
      connect(absoluteVelocity.frame_a, pointMass.frame_a) annotation(
        Line(points = {{20, 8}, {-2, 8}}, color = {95, 95, 95}));
      connect(dragForce.y, force.force) annotation(
        Line(points = {{16, -40}, {-1.8, -40}, {-1.8, -33.8}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteVelocity.v, dragForce.u) annotation(
        Line(points = {{42, 8}, {44, 8}, {44, -40}, {37, -40}}, color = {0, 0, 127}, thickness = 0.5));
      annotation(
        Diagram);
    end DragSystem;

    block DragForce
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Input Signals (velocity vector)" annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 2}, extent = {{-10, -10}, {10, 10}})));
      parameter Real rho_w = 1.25 "Density of sea water [kg/m^3]";
      parameter Real Cd = 1 "Normal drag coefficient";
      parameter Real A = 1 "Cross-sectional Area of object [m^2]";
      Real Fd[3];
    equation
      Fd = -0.5*rho_w*Cd*A*(u.*abs(u));
      y = Fd;
    end DragForce;

    block DragForce3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Input Signals (velocity vector)" annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (3D drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      parameter Real rho = 1.25 "Density of fluid [kg/m^3]";
      parameter Real A = 1 "Reference area [m^2]";
      parameter Real Cdx = 1 "Drag coefficient for x-axis";
      parameter Real Cdy = 1 "Drag coefficient for y-axis";
      parameter Real Cdz = 1 "Drag coefficient for z-axis";
      parameter Real Cd[3, 3] = diagonal({Cdx, Cdy, Cdz});
      Real c "Combined constant term";
      Real Fd[3] "3D drag force vector";
    equation
      c = 0.5*rho*A;
      Fd = -c*Cd*(u.*abs(u));
      y = Fd;
    end DragForce3D;

    block PTO3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] annotation(
        Placement(transformation(origin = {-106, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-98, 50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput s[3] annotation(
        Placement(transformation(origin = {-106, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-98, -50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (3D drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      parameter Real Kpx = 0.1 "Proportional gain for x-axis";
      parameter Real Kpy = 0.1 "Proportional gain for y-axis";
      parameter Real Kpz = 0.1 "Proportional gain for z-axis";
      parameter Real Kp[3, 3] = diagonal({Kpx, Kpy, Kpz});
      parameter Real Kix = 0.1 "Integral gain for x-axis";
      parameter Real Kiy = 0.1 "Integral gain for y-axis";
      parameter Real Kiz = 0.1 "Integral gain for z-axis";
      parameter Real Ki[3, 3] = diagonal({Kix, Kiy, Kiz});
      Real Fp[3] "PTO";
    equation
      Fp = Kp*u + Ki*s;
      y = -Fp;
    end PTO3D;

    block HydrostaticForce3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] annotation(
        Placement(transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, 0}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Output Signals (drag force vector)" annotation(
        Placement(transformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 2}, extent = {{-10, -10}, {10, 10}})));
      parameter Real G1 = 0 "hydrostatic restoring coefficients for x-axis";
      parameter Real G2 = 0 "hydrostatic restoring coefficients for y-axis";
      parameter Real G3 = 1 "hydrostatic restoring coefficients for z-axis";
      parameter Real G[3, 3] = diagonal({G1, G2, G3});
    equation
      y = -G*u;
    end HydrostaticForce3D;

    model HydrodynamicBlock3D
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition absolutePosition annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {-50, 30}, extent = {{-10, -10}, {10, 10}})));
      DragForce3D dragForce3D(Cdx = 0.01, Cdy = 0.01, Cdz = 0.01, rho = 10) annotation(
        Placement(transformation(origin = {-8, 30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {36, 30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force1 annotation(
        Placement(transformation(origin = {36, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force2 annotation(
        Placement(transformation(origin = {36, -30}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      PTO3D pto3d annotation(
        Placement(transformation(origin = {-8, -30}, extent = {{-10, -10}, {10, 10}})));
      HydrostaticForce3D hydrostaticForce3D annotation(
        Placement(transformation(origin = {-8, 0}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(absoluteVelocity.v, dragForce3D.u) annotation(
        Line(points = {{-39, 30}, {-19, 30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(dragForce3D.y, force.force) annotation(
        Line(points = {{2.8, 30}, {24.8, 30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(frame_a, absolutePosition.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
      connect(frame_a, absoluteVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, 30}}));
      connect(force1.frame_b, frame_b) annotation(
        Line(points = {{46, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(force.frame_b, frame_b) annotation(
        Line(points = {{46, 30}, {80, 30}, {80, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(force2.frame_b, frame_b) annotation(
        Line(points = {{46, -30}, {80, -30}, {80, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(pto3d.y, force2.force) annotation(
        Line(points = {{2, -30}, {24, -30}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce3D.y, force1.force) annotation(
        Line(points = {{2, 0}, {24, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, hydrostaticForce3D.u) annotation(
        Line(points = {{-38, 0}, {-18, 0}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absoluteVelocity.v, pto3d.u) annotation(
        Line(points = {{-38, 30}, {-30, 30}, {-30, -24}, {-18, -24}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, pto3d.s) annotation(
        Line(points = {{-38, 0}, {-34, 0}, {-34, -34}, {-18, -34}}, color = {0, 0, 127}, thickness = 0.5));
    end HydrodynamicBlock3D;

    model HydrodynamicBlock6DUPD
      extends Modelica.Blocks.Icons.Block;
      Modelica.Mechanics.MultiBody.Sensors.AbsolutePosition absolutePosition annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteVelocity absoluteVelocity annotation(
        Placement(transformation(origin = {-50, 40}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      HydrostaticForce6D hydrostaticForce6D(enableHydrostaticForce = true) annotation(
        Placement(transformation(origin = {18, -38}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForceAndTorque forceAndTorque2 annotation(
        Placement(transformation(origin = {60, -40}, extent = {{-10, 10}, {10, -10}}, rotation = -0)));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngularVelocity absoluteAngularVelocity annotation(
        Placement(transformation(origin = {-50, -32}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Sensors.AbsoluteAngles absoluteAngles annotation(
        Placement(transformation(origin = {-50, -60}, extent = {{-10, -10}, {10, 10}})));
      RadiationF radiationF(enableRadiationForce = true) annotation(
        Placement(transformation(origin = {18, 68}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Forces.WorldForce force annotation(
        Placement(transformation(origin = {56, 68}, extent = {{-10, -10}, {10, 10}})));
    equation
      connect(frame_a, absolutePosition.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
      connect(absolutePosition.r, hydrostaticForce6D.u) annotation(
        Line(points = {{-38, 0}, {-32, 0}, {-32, -33}, {8, -33}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.y, forceAndTorque2.force) annotation(
        Line(points = {{28, -32}, {48, -32}, {48, -34}}, color = {0, 0, 127}, thickness = 0.5));
      connect(hydrostaticForce6D.y1, forceAndTorque2.torque) annotation(
        Line(points = {{28, -42}, {48, -42}, {48, -46}}, color = {0, 0, 127}, thickness = 0.5));
      connect(forceAndTorque2.frame_b, frame_b) annotation(
        Line(points = {{70, -40}, {78, -40}, {78, 0}, {102, 0}}, color = {95, 95, 95}));
      connect(frame_a, absoluteVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, 40}}));
      connect(frame_a, absoluteAngularVelocity.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, -32}}));
      connect(absoluteAngularVelocity.w, hydrostaticForce6D.theta) annotation(
        Line(points = {{-38, -32}, {-32, -32}, {-32, -42}, {8, -42}}, color = {0, 0, 127}, thickness = 0.5));
      connect(frame_a, absoluteAngles.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}, {-60, -60}}));
      connect(absoluteVelocity.v, radiationF.v) annotation(
        Line(points = {{-38, 40}, {-38, 72}, {6, 72}}, color = {0, 0, 127}, thickness = 0.5));
      connect(absolutePosition.r, radiationF.z) annotation(
        Line(points = {{-38, 0}, {-10, 0}, {-10, 64}, {6, 64}}, color = {0, 0, 127}, thickness = 0.5));
      connect(radiationF.y, force.force) annotation(
        Line(points = {{30, 68}, {44, 68}}, color = {0, 0, 127}, thickness = 0.5));
      connect(force.frame_b, frame_b) annotation(
        Line(points = {{66, 68}, {78, 68}, {78, 0}, {102, 0}}, color = {95, 95, 95}));
    end HydrodynamicBlock6DUPD;

    block HydrostaticForce6DUPD
      extends Modelica.Blocks.Icons.Block;
      Modelica.Blocks.Interfaces.RealInput u[3] "Linear displacement" annotation(
        Placement(transformation(origin = {-106, 50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, 50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealInput theta[3] "Angular displacement" annotation(
        Placement(transformation(origin = {-106, -50}, extent = {{-20, -20}, {20, 20}}), iconTransformation(origin = {-96, -50}, extent = {{-20, -20}, {20, 20}})));
      Modelica.Blocks.Interfaces.RealOutput y[3] "Translational hydrostatic force" annotation(
        Placement(transformation(origin = {108, 50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, 50}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Blocks.Interfaces.RealOutput y1[3] "Rotational hydrostatic torque" annotation(
        Placement(transformation(origin = {108, -50}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {102, -50}, extent = {{-10, -10}, {10, 10}})));
      parameter Real G1 = 0 "Hydrostatic restoring coefficient for x-axis translation";
      parameter Real G2 = 0 "Hydrostatic restoring coefficient for y-axis translation";
      parameter Real G3 = 1958672 "Hydrostatic restoring coefficient for z-axis translation";
      parameter Real G4 = 0 "Hydrostatic restoring coefficient for x-axis rotation";
      parameter Real G5 = 0 "Hydrostatic restoring coefficient for y-axis rotation";
      parameter Real G6 = 0 "Hydrostatic restoring coefficient for z-axis rotation";
      parameter Real G[6, 6] = diagonal({G1, G2, G3, G4, G5, G6});
      // Add a switch parameter
      parameter Boolean enableHydrostaticForce = true "Switch to enable/disable hydrostatic force";
      Real F[6] "Hydrostatic force/torque vector";
      Real u_theta[6] "Combined linear and angular displacements";
    equation
      // Combine u and theta into a 6x1 matrix
      u_theta[1:3] = u;
      u_theta[4:6] = theta;
      F = -G*u_theta;
      // Use the switch to conditionally output the force
      if enableHydrostaticForce then
        y = F[1:3];
        y1 = F[4:6];
      else
        y = zeros(3);
        y1 = zeros(3);
      end if;
    end HydrostaticForce6DUPD;

    model BodyHD6D "6-Dimensional Hydrodynamic Body Model"
      extends Modelica.Blocks.Icons.Block;
      // MultiBody connectors
      Modelica.Mechanics.MultiBody.Interfaces.Frame_a frame_a "Input frame" annotation(
        Placement(transformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {-102, 0}, extent = {{-16, -16}, {16, 16}})));
      Modelica.Mechanics.MultiBody.Interfaces.Frame_b frame_b "Output frame" annotation(
        Placement(transformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}}), iconTransformation(origin = {102, 0}, extent = {{-16, -16}, {16, 16}})));
      // Body components
      Modelica.Mechanics.MultiBody.Parts.BodyShape bodyShape(height = 0.1, length = 0.1, m = 1958671, width = 0.1, r_CM = {0, 0, 0}, r = {0, 0, 0}) "Main body with mass and inertia" annotation(
        Placement(transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}})));
      Modelica.Mechanics.MultiBody.Parts.FixedTranslation fixedTranslation(r = {0, 0, 0}, animation = false) "Fixed translation to adjust body position" annotation(
        Placement(transformation(origin = {-20, 0}, extent = {{-10, -10}, {10, 10}})));
      // Parameters for DragForce6D (now part of BodyHD6D)
      parameter Real rho(unit = "kg/m^3") = 1000 "Density of fluid";
      parameter Real A(unit = "m^2") = 1 "Reference area";
      parameter Real Cdx = 100 "Translational drag coefficient for x-axis";
      parameter Real Cdy = 0.01 "Translational drag coefficient for y-axis";
      parameter Real Cdz = 100 "Translational drag coefficient for z-axis";
      parameter Real Crx = 100 "Rotational drag coefficient for x-axis";
      parameter Real Cry = 0.01 "Rotational drag coefficient for y-axis";
      parameter Real Crz = 100 "Rotational drag coefficient for z-axis";
      parameter Boolean enableDragForce = false "Switch to enable/disable drag force calculation";
      // Hydrodynamic forces component
      HydrodynamicBlock6D hydrodynamicBlock6D(rho = rho, A = A, Cdx = Cdx, Cdy = Cdy, Cdz = Cdz, Crx = Crx, Cry = Cry, Crz = Crz, enableDragForce = enableDragForce) "Calculation of hydrodynamic forces and moments" annotation(
        Placement(transformation(origin = {24, 34}, extent = {{-10, -10}, {10, 10}})));
    equation
      // Connect input frame to body
      connect(frame_a, bodyShape.frame_a) annotation(
        Line(points = {{-102, 0}, {-60, 0}}));
      // Connect body to fixed translation
      connect(bodyShape.frame_b, fixedTranslation.frame_a) annotation(
        Line(points = {{-40, 0}, {-30, 0}}, color = {95, 95, 95}));
      // Connect fixed translation to output frame
      connect(fixedTranslation.frame_b, frame_b) annotation(
        Line(points = {{-10, 0}, {102, 0}}, color = {95, 95, 95}));
      // Connect hydrodynamic block to body
      connect(hydrodynamicBlock6D.frame_a, fixedTranslation.frame_b) annotation(
        Line(points = {{14, 34}, {-10, 34}, {-10, 0}}, color = {95, 95, 95}));
      connect(hydrodynamicBlock6D.frame_b, fixedTranslation.frame_b) annotation(
        Line(points = {{34, 34}, {46, 34}, {46, 0}, {-10, 0}}, color = {95, 95, 95}));
      annotation(
        Documentation(info = "<html>
    <p>This model represents a 6-dimensional hydrodynamic body, incorporating both rigid body dynamics and hydrodynamic forces.</p>
    <p>The model consists of:</p>
    <ul>
      <li>A main body with specified mass and inertia</li>
      <li>A fixed translation component to adjust the body's position</li>
      <li>A hydrodynamic block that calculates and applies various hydrodynamic forces and moments</li>
    </ul>
    <p>Inputs:</p>
    <ul>
      <li><code>frame_a</code>: Input frame for external connections</li>
    </ul>
    <p>Outputs:</p>
    <ul>
      <li><code>frame_b</code>: Output frame for external connections</li>
    </ul>
    <p>The hydrodynamic forces are applied to the body through the HydrodynamicBlock6D component, 
    which calculates drag, power take-off, hydrostatic, and radiation forces based on the body's motion.</p>
    <p>Note: The body's shape parameters (height, length, width) and mass can be adjusted as needed for specific applications.</p>
  </html>"),
        Icon(graphics = {Text(origin = {-2, -95}, extent = {{-58, 15}, {62, -5}}, textString = "Rigid Body 6D"), Rectangle(origin = {3, -10}, fillColor = {211, 215, 207}, fillPattern = FillPattern.Solid, extent = {{-95, 50}, {89, -50}}), Text(origin = {0, 54}, extent = {{-100, 16}, {100, -24}}, textString = "%name")}));
    end BodyHD6D;

    model ExcitationForce "1D Excitation Force Model for Hydrodynamic Systems"
      extends Modelica.Blocks.Icons.Block;
      // Output connector
      Modelica.Blocks.Interfaces.RealOutput y[3] "Excitation force vector [N] (only vertical component non-zero)" annotation(
        Placement(transformation(origin = {110, 0}, extent = {{-10, -10}, {10, 10}}), iconTransformation(origin = {108, 0}, extent = {{-10, -10}, {10, 10}})));
      // Import the CombiTimeTable for data input
      import Modelica.Blocks.Sources.CombiTimeTable;
      // Excitation force data input
      CombiTimeTable excitationData(tableOnFile = true, fileName = "C:/Users/Duke/SysModel2024/DragSystem/ExcF9.csv", tableName = "excitation", columns = {2}, extrapolation = Modelica.Blocks.Types.Extrapolation.HoldLastPoint) "Time series data for vertical excitation force";
    equation
      // Apply excitation force only in the vertical direction (third element)
      y = {0, 0, excitationData.y[1]};
      annotation(
        Documentation(info = "<html>
    <h4>1D Excitation Force Model for Hydrodynamic Systems</h4>
    <p>This model represents the excitation force for hydrodynamic systems, 
    considering only the vertical direction (1D model).</p>
    
    <p>Model Description:</p>
    <p>The excitation force is applied solely in the vertical direction (third element of the output vector). 
    The force magnitude is obtained from a time series data file, allowing for the representation of 
    time-varying excitation forces such as those caused by waves in marine applications.</p>
    
    <p>Inputs:</p>
    <ul>
      <li>No direct inputs. The excitation force is read from an external CSV file.</li>
    </ul>
    
    <p>Outputs:</p>
    <ul>
      <li><code>y[3]</code>: Excitation force vector [N] (force applied only in the vertical direction, third element)</li>
    </ul>
    
    <p>Key Components:</p>
    <ul>
      <li><code>excitationData</code>: CombiTimeTable that reads the excitation force data from a CSV file</li>
    </ul>
    
    <p>File Input:</p>
    <ul>
      <li>File path: C:/Users/Duke/SysModel2024/DragSystem/ExcF6.csv</li>
      <li>Table name: 'excitation'</li>
      <li>Only the second column of the CSV file is used (assumed to contain force values)</li>
    </ul>
    
    <p>Notes:</p>
    <ul>
      <li>The model assumes that the excitation force acts only in the vertical direction, simplifying the calculations for many marine applications.</li>
      <li>The excitation force data is held at its last value if the simulation time exceeds the data in the input file.</li>
      <li>Ensure that the CSV file path is correct and the file is accessible for successful simulation.</li>
    </ul>
  </html>"),
        Icon(graphics = {Text(extent = {{-100, 100}, {100, -100}}, textString = "1D Exc F", fontName = "Arial")}));
    end ExcitationForce;
  end Archive;
  annotation(
    Icon(graphics = {Line(points = {{-90, 40}, {-60, 60}, {-30, 20}, {0, 60}, {30, 20}, {60, 60}, {90, 40}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Line(points = {{-90, -40}, {-60, -20}, {-30, -60}, {0, -20}, {30, -60}, {60, -20}, {90, -40}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Line(points = {{-90, 0}, {-60, 20}, {-30, -20}, {0, 20}, {30, -20}, {60, 20}, {90, 0}}, color = {0, 0, 200}, thickness = 2, smooth = Smooth.Bezier), Ellipse(extent = {{-20, 20}, {20, -20}}, lineColor = {0, 0, 0}, fillColor = // Black circle
    {0, 0, 0}, fillPattern = // Light gray fill
    FillPattern.Solid// Solid fill
    )}),
    Documentation(info = "<html>
    <p><strong>Hydrodynamic Package</strong></p>
    
    <p>This package contains models and components for simulating hydrodynamic systems, 
    particularly focused on Wave Energy Converters (WECs). The current implementation 
    includes a variety of models and force components across several sub-packages.</p>
    
    <p><strong>Key Sub-Packages:</strong></p>
    <ul>
        <li><strong>Example:</strong>
            <ul>
                <li><strong>SingleBodyWEC1D:</strong> A 1D single-body Wave Energy Converter model.</li>
            </ul>
        </li>
        <li><strong>Forces:</strong>
            <ul>
                <li><strong>HydrostaticForce6D:</strong> Calculates 6D hydrostatic forces and torques.</li>
                <li><strong>RadiationForce:</strong> Computes radiation forces (currently 1D, vertical direction only).</li>
                <li><strong>DragForce6D:</strong> Computes 6D drag forces and torques.</li>
                <li><strong>PTO6D:</strong> Models a 6D Power Take-Off system.</li>
                <li><strong>HydrodynamicBlock6D:</strong> Calculates and applies 6D hydrodynamic forces and moments.</li>
                <li><strong>RadiationF3D:</strong> An extended version of RadiationForce for 3D modeling.</li>
            </ul>
        </li>
        <li><strong>WaveProfile:</strong>
            <ul>
                <li><strong>RegularWave:</strong> A linear wave model.</li>
                <li><strong>IrregularWave:</strong> Includes Pierson-Moskowitz, Bretschneider, JONSWAP wave models, and various irregular parameters.</li>
            </ul>
        </li>
        <li><strong>Connector:</strong> Contains connector definitions for hydrodynamic components.</li>
        <li><strong>Internal:</strong> Contains internal utility components used across the package.</li>
        <li><strong>Archive:</strong> Contains deprecated or experimental models and components.</li>
    </ul>
    
    <p><strong>Current Capabilities:</strong></p>
    <p>The package allows for modeling of a single-body WEC with the following features:</p>
    <ul>
        <li>6D modeling of drag, PTO, and hydrostatic forces</li>
        <li>1D and 3D modeling of radiation forces</li>
        <li>External excitation force input</li>
        <li>Rigid body dynamics in 6D</li>
        <li>Wave profile modeling including regular and irregular waves</li>
    </ul>
    
    <p><strong>Limitations and Future Work:</strong></p>
    <ul>
        <li>Further extension of radiation forces to full 6D capabilities</li>
        <li>Expansion of the excitation force model to include full 6D capabilities</li>
        <li>Implementation of additional WEC configurations (e.g., multi-body systems)</li>
    </ul>
    
    <p>This package provides a foundation for hydrodynamic simulations in Modelica, 
    particularly suited for Wave Energy Converter applications. Users can leverage 
    these components to build and simulate various marine energy devices.</p>
</html>"),
    uses(Modelica(version = "4.0.0")));
end Hydrodynamic;
